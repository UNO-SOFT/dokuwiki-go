// Code generated by Microsoft Kiota - DO NOT EDIT.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package corelockpages

import (
    "context"
    i2ae4187f7daee263371cb1c977df639813ab50ffa529013b7437480d1ec0158f "github.com/microsoft/kiota-abstractions-go"
)

// CoreLockPagesRequestBuilder builds and executes requests for operations under \core.lockPages
type CoreLockPagesRequestBuilder struct {
    i2ae4187f7daee263371cb1c977df639813ab50ffa529013b7437480d1ec0158f.BaseRequestBuilder
}
// CoreLockPagesRequestBuilderPostRequestConfiguration configuration for the request such as headers, query parameters, and middleware options.
type CoreLockPagesRequestBuilderPostRequestConfiguration struct {
    // Request headers
    Headers *i2ae4187f7daee263371cb1c977df639813ab50ffa529013b7437480d1ec0158f.RequestHeaders
    // Request options
    Options []i2ae4187f7daee263371cb1c977df639813ab50ffa529013b7437480d1ec0158f.RequestOption
}
// NewCoreLockPagesRequestBuilderInternal instantiates a new CoreLockPagesRequestBuilder and sets the default values.
func NewCoreLockPagesRequestBuilderInternal(pathParameters map[string]string, requestAdapter i2ae4187f7daee263371cb1c977df639813ab50ffa529013b7437480d1ec0158f.RequestAdapter)(*CoreLockPagesRequestBuilder) {
    m := &CoreLockPagesRequestBuilder{
        BaseRequestBuilder: *i2ae4187f7daee263371cb1c977df639813ab50ffa529013b7437480d1ec0158f.NewBaseRequestBuilder(requestAdapter, "{+baseurl}/core.lockPages", pathParameters),
    }
    return m
}
// NewCoreLockPagesRequestBuilder instantiates a new CoreLockPagesRequestBuilder and sets the default values.
func NewCoreLockPagesRequestBuilder(rawUrl string, requestAdapter i2ae4187f7daee263371cb1c977df639813ab50ffa529013b7437480d1ec0158f.RequestAdapter)(*CoreLockPagesRequestBuilder) {
    urlParams := make(map[string]string)
    urlParams["request-raw-url"] = rawUrl
    return NewCoreLockPagesRequestBuilderInternal(urlParams, requestAdapter)
}
// Post this call will try to lock all given pages. It will return a list of pages that weresuccessfully locked. If a page could not be locked, eg. because a different user iscurrently holding a lock, that page will be missing from the returned list.You should always ensure that the list of returned pages matches the given list ofpages. It's up to you to decide how to handle failed locking.Note: you can only lock pages that you have write access for. It is possible to createa lock for a page that does not exist, yet.Note: it is not necessary to lock a page before saving it. The `savePage()` call willautomatically lock and unlock the page for you. However if you plan to do relatedoperations on multiple pages, locking them all at once beforehand can be useful.
// Deprecated: This method is obsolete. Use PostAsLockPagesPostResponse instead.
// returns a LockPagesResponseable when successful
func (m *CoreLockPagesRequestBuilder) Post(ctx context.Context, body LockPagesPostRequestBodyable, requestConfiguration *CoreLockPagesRequestBuilderPostRequestConfiguration)(LockPagesResponseable, error) {
    requestInfo, err := m.ToPostRequestInformation(ctx, body, requestConfiguration);
    if err != nil {
        return nil, err
    }
    res, err := m.BaseRequestBuilder.RequestAdapter.Send(ctx, requestInfo, CreateLockPagesResponseFromDiscriminatorValue, nil)
    if err != nil {
        return nil, err
    }
    if res == nil {
        return nil, nil
    }
    return res.(LockPagesResponseable), nil
}
// PostAsLockPagesPostResponse this call will try to lock all given pages. It will return a list of pages that weresuccessfully locked. If a page could not be locked, eg. because a different user iscurrently holding a lock, that page will be missing from the returned list.You should always ensure that the list of returned pages matches the given list ofpages. It's up to you to decide how to handle failed locking.Note: you can only lock pages that you have write access for. It is possible to createa lock for a page that does not exist, yet.Note: it is not necessary to lock a page before saving it. The `savePage()` call willautomatically lock and unlock the page for you. However if you plan to do relatedoperations on multiple pages, locking them all at once beforehand can be useful.
// returns a LockPagesPostResponseable when successful
func (m *CoreLockPagesRequestBuilder) PostAsLockPagesPostResponse(ctx context.Context, body LockPagesPostRequestBodyable, requestConfiguration *CoreLockPagesRequestBuilderPostRequestConfiguration)(LockPagesPostResponseable, error) {
    requestInfo, err := m.ToPostRequestInformation(ctx, body, requestConfiguration);
    if err != nil {
        return nil, err
    }
    res, err := m.BaseRequestBuilder.RequestAdapter.Send(ctx, requestInfo, CreateLockPagesPostResponseFromDiscriminatorValue, nil)
    if err != nil {
        return nil, err
    }
    if res == nil {
        return nil, nil
    }
    return res.(LockPagesPostResponseable), nil
}
// ToPostRequestInformation this call will try to lock all given pages. It will return a list of pages that weresuccessfully locked. If a page could not be locked, eg. because a different user iscurrently holding a lock, that page will be missing from the returned list.You should always ensure that the list of returned pages matches the given list ofpages. It's up to you to decide how to handle failed locking.Note: you can only lock pages that you have write access for. It is possible to createa lock for a page that does not exist, yet.Note: it is not necessary to lock a page before saving it. The `savePage()` call willautomatically lock and unlock the page for you. However if you plan to do relatedoperations on multiple pages, locking them all at once beforehand can be useful.
// returns a *RequestInformation when successful
func (m *CoreLockPagesRequestBuilder) ToPostRequestInformation(ctx context.Context, body LockPagesPostRequestBodyable, requestConfiguration *CoreLockPagesRequestBuilderPostRequestConfiguration)(*i2ae4187f7daee263371cb1c977df639813ab50ffa529013b7437480d1ec0158f.RequestInformation, error) {
    requestInfo := i2ae4187f7daee263371cb1c977df639813ab50ffa529013b7437480d1ec0158f.NewRequestInformationWithMethodAndUrlTemplateAndPathParameters(i2ae4187f7daee263371cb1c977df639813ab50ffa529013b7437480d1ec0158f.POST, m.BaseRequestBuilder.UrlTemplate, m.BaseRequestBuilder.PathParameters)
    if requestConfiguration != nil {
        requestInfo.Headers.AddAll(requestConfiguration.Headers)
        requestInfo.AddRequestOptions(requestConfiguration.Options)
    }
    requestInfo.Headers.TryAdd("Accept", "application/json")
    err := requestInfo.SetContentFromParsable(ctx, m.BaseRequestBuilder.RequestAdapter, "application/json", body)
    if err != nil {
        return nil, err
    }
    return requestInfo, nil
}
// WithUrl returns a request builder with the provided arbitrary URL. Using this method means any other path or query parameters are ignored.
// returns a *CoreLockPagesRequestBuilder when successful
func (m *CoreLockPagesRequestBuilder) WithUrl(rawUrl string)(*CoreLockPagesRequestBuilder) {
    return NewCoreLockPagesRequestBuilder(rawUrl, m.BaseRequestBuilder.RequestAdapter);
}
