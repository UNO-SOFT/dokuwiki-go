/*
DokuWiki API

The DokuWiki API OpenAPI specification

API version: 14
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package dokuwiki

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// PluginsAPIService PluginsAPI service
type PluginsAPIService service

type ApiPluginAclAddAclRequest struct {
	ctx context.Context
	ApiService *PluginsAPIService
	pluginAclAddAclRequest *PluginAclAddAclRequest
}

func (r ApiPluginAclAddAclRequest) PluginAclAddAclRequest(pluginAclAddAclRequest PluginAclAddAclRequest) ApiPluginAclAddAclRequest {
	r.pluginAclAddAclRequest = &pluginAclAddAclRequest
	return r
}

func (r ApiPluginAclAddAclRequest) Execute() (*PluginAclAddAcl200Response, *http.Response, error) {
	return r.ApiService.PluginAclAddAclExecute(r)
}

/*
PluginAclAddAcl Add a new ACL rule to the config



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPluginAclAddAclRequest
*/
func (a *PluginsAPIService) PluginAclAddAcl(ctx context.Context) ApiPluginAclAddAclRequest {
	return ApiPluginAclAddAclRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PluginAclAddAcl200Response
func (a *PluginsAPIService) PluginAclAddAclExecute(r ApiPluginAclAddAclRequest) (*PluginAclAddAcl200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PluginAclAddAcl200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.PluginAclAddAcl")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/plugin.acl.addAcl"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.pluginAclAddAclRequest == nil {
		return localVarReturnValue, nil, reportError("pluginAclAddAclRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.pluginAclAddAclRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPluginAclDelAclRequest struct {
	ctx context.Context
	ApiService *PluginsAPIService
	pluginAclDelAclRequest *PluginAclDelAclRequest
}

func (r ApiPluginAclDelAclRequest) PluginAclDelAclRequest(pluginAclDelAclRequest PluginAclDelAclRequest) ApiPluginAclDelAclRequest {
	r.pluginAclDelAclRequest = &pluginAclDelAclRequest
	return r
}

func (r ApiPluginAclDelAclRequest) Execute() (*PluginAclDelAcl200Response, *http.Response, error) {
	return r.ApiService.PluginAclDelAclExecute(r)
}

/*
PluginAclDelAcl Remove an entry from ACL config



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPluginAclDelAclRequest
*/
func (a *PluginsAPIService) PluginAclDelAcl(ctx context.Context) ApiPluginAclDelAclRequest {
	return ApiPluginAclDelAclRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PluginAclDelAcl200Response
func (a *PluginsAPIService) PluginAclDelAclExecute(r ApiPluginAclDelAclRequest) (*PluginAclDelAcl200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PluginAclDelAcl200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.PluginAclDelAcl")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/plugin.acl.delAcl"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.pluginAclDelAclRequest == nil {
		return localVarReturnValue, nil, reportError("pluginAclDelAclRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.pluginAclDelAclRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPluginAclListAclsRequest struct {
	ctx context.Context
	ApiService *PluginsAPIService
	body *nil
}

func (r ApiPluginAclListAclsRequest) Body(body nil) ApiPluginAclListAclsRequest {
	r.body = &body
	return r
}

func (r ApiPluginAclListAclsRequest) Execute() (*PluginAclListAcls200Response, *http.Response, error) {
	return r.ApiService.PluginAclListAclsExecute(r)
}

/*
PluginAclListAcls Get the list all ACL config entries



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPluginAclListAclsRequest
*/
func (a *PluginsAPIService) PluginAclListAcls(ctx context.Context) ApiPluginAclListAclsRequest {
	return ApiPluginAclListAclsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PluginAclListAcls200Response
func (a *PluginsAPIService) PluginAclListAclsExecute(r ApiPluginAclListAclsRequest) (*PluginAclListAcls200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PluginAclListAcls200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.PluginAclListAcls")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/plugin.acl.listAcls"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPluginAichatAskRequest struct {
	ctx context.Context
	ApiService *PluginsAPIService
	pluginAichatAskRequest *PluginAichatAskRequest
}

func (r ApiPluginAichatAskRequest) PluginAichatAskRequest(pluginAichatAskRequest PluginAichatAskRequest) ApiPluginAichatAskRequest {
	r.pluginAichatAskRequest = &pluginAichatAskRequest
	return r
}

func (r ApiPluginAichatAskRequest) Execute() (*PluginAichatAsk200Response, *http.Response, error) {
	return r.ApiService.PluginAichatAskExecute(r)
}

/*
PluginAichatAsk Ask the LLM a question

Sends the given question to the LLM and returns the answer, including the used sources.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPluginAichatAskRequest
*/
func (a *PluginsAPIService) PluginAichatAsk(ctx context.Context) ApiPluginAichatAskRequest {
	return ApiPluginAichatAskRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PluginAichatAsk200Response
func (a *PluginsAPIService) PluginAichatAskExecute(r ApiPluginAichatAskRequest) (*PluginAichatAsk200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PluginAichatAsk200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.PluginAichatAsk")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/plugin.aichat.ask"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.pluginAichatAskRequest == nil {
		return localVarReturnValue, nil, reportError("pluginAichatAskRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.pluginAichatAskRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPluginAichatSimilarRequest struct {
	ctx context.Context
	ApiService *PluginsAPIService
	pluginAichatSimilarRequest *PluginAichatSimilarRequest
}

func (r ApiPluginAichatSimilarRequest) PluginAichatSimilarRequest(pluginAichatSimilarRequest PluginAichatSimilarRequest) ApiPluginAichatSimilarRequest {
	r.pluginAichatSimilarRequest = &pluginAichatSimilarRequest
	return r
}

func (r ApiPluginAichatSimilarRequest) Execute() (*PluginAichatSimilar200Response, *http.Response, error) {
	return r.ApiService.PluginAichatSimilarExecute(r)
}

/*
PluginAichatSimilar Get page chunks similar to a given query

Uses the given query to find similar pages in the wiki. Returns the most similar chunks.

This call returns chunks, not pages. So a page may returned multiple times when different chunks of it
are similar to the query.

Note that this call may return less results than requested depending on the used vector store.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPluginAichatSimilarRequest
*/
func (a *PluginsAPIService) PluginAichatSimilar(ctx context.Context) ApiPluginAichatSimilarRequest {
	return ApiPluginAichatSimilarRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PluginAichatSimilar200Response
func (a *PluginsAPIService) PluginAichatSimilarExecute(r ApiPluginAichatSimilarRequest) (*PluginAichatSimilar200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PluginAichatSimilar200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.PluginAichatSimilar")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/plugin.aichat.similar"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.pluginAichatSimilarRequest == nil {
		return localVarReturnValue, nil, reportError("pluginAichatSimilarRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.pluginAichatSimilarRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPluginExtensionDisableRequest struct {
	ctx context.Context
	ApiService *PluginsAPIService
	pluginExtensionDisableRequest *PluginExtensionDisableRequest
}

func (r ApiPluginExtensionDisableRequest) PluginExtensionDisableRequest(pluginExtensionDisableRequest PluginExtensionDisableRequest) ApiPluginExtensionDisableRequest {
	r.pluginExtensionDisableRequest = &pluginExtensionDisableRequest
	return r
}

func (r ApiPluginExtensionDisableRequest) Execute() (*PluginExtensionEnable200Response, *http.Response, error) {
	return r.ApiService.PluginExtensionDisableExecute(r)
}

/*
PluginExtensionDisable Disable a specific extension



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPluginExtensionDisableRequest
*/
func (a *PluginsAPIService) PluginExtensionDisable(ctx context.Context) ApiPluginExtensionDisableRequest {
	return ApiPluginExtensionDisableRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PluginExtensionEnable200Response
func (a *PluginsAPIService) PluginExtensionDisableExecute(r ApiPluginExtensionDisableRequest) (*PluginExtensionEnable200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PluginExtensionEnable200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.PluginExtensionDisable")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/plugin.extension.disable"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.pluginExtensionDisableRequest == nil {
		return localVarReturnValue, nil, reportError("pluginExtensionDisableRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.pluginExtensionDisableRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPluginExtensionEnableRequest struct {
	ctx context.Context
	ApiService *PluginsAPIService
	pluginExtensionEnableRequest *PluginExtensionEnableRequest
}

func (r ApiPluginExtensionEnableRequest) PluginExtensionEnableRequest(pluginExtensionEnableRequest PluginExtensionEnableRequest) ApiPluginExtensionEnableRequest {
	r.pluginExtensionEnableRequest = &pluginExtensionEnableRequest
	return r
}

func (r ApiPluginExtensionEnableRequest) Execute() (*PluginExtensionEnable200Response, *http.Response, error) {
	return r.ApiService.PluginExtensionEnableExecute(r)
}

/*
PluginExtensionEnable Enable a specific extension



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPluginExtensionEnableRequest
*/
func (a *PluginsAPIService) PluginExtensionEnable(ctx context.Context) ApiPluginExtensionEnableRequest {
	return ApiPluginExtensionEnableRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PluginExtensionEnable200Response
func (a *PluginsAPIService) PluginExtensionEnableExecute(r ApiPluginExtensionEnableRequest) (*PluginExtensionEnable200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PluginExtensionEnable200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.PluginExtensionEnable")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/plugin.extension.enable"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.pluginExtensionEnableRequest == nil {
		return localVarReturnValue, nil, reportError("pluginExtensionEnableRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.pluginExtensionEnableRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPluginExtensionInstallRequest struct {
	ctx context.Context
	ApiService *PluginsAPIService
	pluginExtensionInstallRequest *PluginExtensionInstallRequest
}

func (r ApiPluginExtensionInstallRequest) PluginExtensionInstallRequest(pluginExtensionInstallRequest PluginExtensionInstallRequest) ApiPluginExtensionInstallRequest {
	r.pluginExtensionInstallRequest = &pluginExtensionInstallRequest
	return r
}

func (r ApiPluginExtensionInstallRequest) Execute() (*PluginExtensionInstall200Response, *http.Response, error) {
	return r.ApiService.PluginExtensionInstallExecute(r)
}

/*
PluginExtensionInstall Install a specific extension

This will also install dependencies, so more than the given extension may be installed.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPluginExtensionInstallRequest
*/
func (a *PluginsAPIService) PluginExtensionInstall(ctx context.Context) ApiPluginExtensionInstallRequest {
	return ApiPluginExtensionInstallRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PluginExtensionInstall200Response
func (a *PluginsAPIService) PluginExtensionInstallExecute(r ApiPluginExtensionInstallRequest) (*PluginExtensionInstall200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PluginExtensionInstall200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.PluginExtensionInstall")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/plugin.extension.install"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.pluginExtensionInstallRequest == nil {
		return localVarReturnValue, nil, reportError("pluginExtensionInstallRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.pluginExtensionInstallRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPluginExtensionListRequest struct {
	ctx context.Context
	ApiService *PluginsAPIService
	body *nil
}

func (r ApiPluginExtensionListRequest) Body(body nil) ApiPluginExtensionListRequest {
	r.body = &body
	return r
}

func (r ApiPluginExtensionListRequest) Execute() (*PluginExtensionList200Response, *http.Response, error) {
	return r.ApiService.PluginExtensionListExecute(r)
}

/*
PluginExtensionList List installed extensions

This lists all installed extensions. The list is not sorted in any way.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPluginExtensionListRequest
*/
func (a *PluginsAPIService) PluginExtensionList(ctx context.Context) ApiPluginExtensionListRequest {
	return ApiPluginExtensionListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PluginExtensionList200Response
func (a *PluginsAPIService) PluginExtensionListExecute(r ApiPluginExtensionListRequest) (*PluginExtensionList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PluginExtensionList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.PluginExtensionList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/plugin.extension.list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPluginExtensionSearchRequest struct {
	ctx context.Context
	ApiService *PluginsAPIService
	pluginExtensionSearchRequest *PluginExtensionSearchRequest
}

func (r ApiPluginExtensionSearchRequest) PluginExtensionSearchRequest(pluginExtensionSearchRequest PluginExtensionSearchRequest) ApiPluginExtensionSearchRequest {
	r.pluginExtensionSearchRequest = &pluginExtensionSearchRequest
	return r
}

func (r ApiPluginExtensionSearchRequest) Execute() (*PluginExtensionSearch200Response, *http.Response, error) {
	return r.ApiService.PluginExtensionSearchExecute(r)
}

/*
PluginExtensionSearch Search for extensions in the repository



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPluginExtensionSearchRequest
*/
func (a *PluginsAPIService) PluginExtensionSearch(ctx context.Context) ApiPluginExtensionSearchRequest {
	return ApiPluginExtensionSearchRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PluginExtensionSearch200Response
func (a *PluginsAPIService) PluginExtensionSearchExecute(r ApiPluginExtensionSearchRequest) (*PluginExtensionSearch200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PluginExtensionSearch200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.PluginExtensionSearch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/plugin.extension.search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.pluginExtensionSearchRequest == nil {
		return localVarReturnValue, nil, reportError("pluginExtensionSearchRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.pluginExtensionSearchRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPluginExtensionUninstallRequest struct {
	ctx context.Context
	ApiService *PluginsAPIService
	pluginExtensionUninstallRequest *PluginExtensionUninstallRequest
}

func (r ApiPluginExtensionUninstallRequest) PluginExtensionUninstallRequest(pluginExtensionUninstallRequest PluginExtensionUninstallRequest) ApiPluginExtensionUninstallRequest {
	r.pluginExtensionUninstallRequest = &pluginExtensionUninstallRequest
	return r
}

func (r ApiPluginExtensionUninstallRequest) Execute() (*PluginExtensionEnable200Response, *http.Response, error) {
	return r.ApiService.PluginExtensionUninstallExecute(r)
}

/*
PluginExtensionUninstall Uninstall a specific extension



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPluginExtensionUninstallRequest
*/
func (a *PluginsAPIService) PluginExtensionUninstall(ctx context.Context) ApiPluginExtensionUninstallRequest {
	return ApiPluginExtensionUninstallRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PluginExtensionEnable200Response
func (a *PluginsAPIService) PluginExtensionUninstallExecute(r ApiPluginExtensionUninstallRequest) (*PluginExtensionEnable200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PluginExtensionEnable200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.PluginExtensionUninstall")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/plugin.extension.uninstall"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.pluginExtensionUninstallRequest == nil {
		return localVarReturnValue, nil, reportError("pluginExtensionUninstallRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.pluginExtensionUninstallRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPluginMoveRenameMediaRequest struct {
	ctx context.Context
	ApiService *PluginsAPIService
	pluginMoveRenameMediaRequest *PluginMoveRenameMediaRequest
}

func (r ApiPluginMoveRenameMediaRequest) PluginMoveRenameMediaRequest(pluginMoveRenameMediaRequest PluginMoveRenameMediaRequest) ApiPluginMoveRenameMediaRequest {
	r.pluginMoveRenameMediaRequest = &pluginMoveRenameMediaRequest
	return r
}

func (r ApiPluginMoveRenameMediaRequest) Execute() (*PluginMoveRenamePage200Response, *http.Response, error) {
	return r.ApiService.PluginMoveRenameMediaExecute(r)
}

/*
PluginMoveRenameMedia Rename/move a given media file



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPluginMoveRenameMediaRequest
*/
func (a *PluginsAPIService) PluginMoveRenameMedia(ctx context.Context) ApiPluginMoveRenameMediaRequest {
	return ApiPluginMoveRenameMediaRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PluginMoveRenamePage200Response
func (a *PluginsAPIService) PluginMoveRenameMediaExecute(r ApiPluginMoveRenameMediaRequest) (*PluginMoveRenamePage200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PluginMoveRenamePage200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.PluginMoveRenameMedia")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/plugin.move.renameMedia"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.pluginMoveRenameMediaRequest == nil {
		return localVarReturnValue, nil, reportError("pluginMoveRenameMediaRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.pluginMoveRenameMediaRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPluginMoveRenamePageRequest struct {
	ctx context.Context
	ApiService *PluginsAPIService
	pluginMoveRenamePageRequest *PluginMoveRenamePageRequest
}

func (r ApiPluginMoveRenamePageRequest) PluginMoveRenamePageRequest(pluginMoveRenamePageRequest PluginMoveRenamePageRequest) ApiPluginMoveRenamePageRequest {
	r.pluginMoveRenamePageRequest = &pluginMoveRenamePageRequest
	return r
}

func (r ApiPluginMoveRenamePageRequest) Execute() (*PluginMoveRenamePage200Response, *http.Response, error) {
	return r.ApiService.PluginMoveRenamePageExecute(r)
}

/*
PluginMoveRenamePage Rename/move a given page



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPluginMoveRenamePageRequest
*/
func (a *PluginsAPIService) PluginMoveRenamePage(ctx context.Context) ApiPluginMoveRenamePageRequest {
	return ApiPluginMoveRenamePageRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PluginMoveRenamePage200Response
func (a *PluginsAPIService) PluginMoveRenamePageExecute(r ApiPluginMoveRenamePageRequest) (*PluginMoveRenamePage200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PluginMoveRenamePage200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.PluginMoveRenamePage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/plugin.move.renamePage"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.pluginMoveRenamePageRequest == nil {
		return localVarReturnValue, nil, reportError("pluginMoveRenamePageRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.pluginMoveRenamePageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPluginUsermanagerCreateUserRequest struct {
	ctx context.Context
	ApiService *PluginsAPIService
	pluginUsermanagerCreateUserRequest *PluginUsermanagerCreateUserRequest
}

func (r ApiPluginUsermanagerCreateUserRequest) PluginUsermanagerCreateUserRequest(pluginUsermanagerCreateUserRequest PluginUsermanagerCreateUserRequest) ApiPluginUsermanagerCreateUserRequest {
	r.pluginUsermanagerCreateUserRequest = &pluginUsermanagerCreateUserRequest
	return r
}

func (r ApiPluginUsermanagerCreateUserRequest) Execute() (*PluginUsermanagerCreateUser200Response, *http.Response, error) {
	return r.ApiService.PluginUsermanagerCreateUserExecute(r)
}

/*
PluginUsermanagerCreateUser Create a new user

If no password is provided, a password is auto generated. If the user can't be created
by the auth backend a return value of `false` is returned. You need to check this return
value rather than relying on the error code only.

Superuser permission are required to create users.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPluginUsermanagerCreateUserRequest
*/
func (a *PluginsAPIService) PluginUsermanagerCreateUser(ctx context.Context) ApiPluginUsermanagerCreateUserRequest {
	return ApiPluginUsermanagerCreateUserRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PluginUsermanagerCreateUser200Response
func (a *PluginsAPIService) PluginUsermanagerCreateUserExecute(r ApiPluginUsermanagerCreateUserRequest) (*PluginUsermanagerCreateUser200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PluginUsermanagerCreateUser200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.PluginUsermanagerCreateUser")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/plugin.usermanager.createUser"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.pluginUsermanagerCreateUserRequest == nil {
		return localVarReturnValue, nil, reportError("pluginUsermanagerCreateUserRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.pluginUsermanagerCreateUserRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPluginUsermanagerDeleteUserRequest struct {
	ctx context.Context
	ApiService *PluginsAPIService
	pluginUsermanagerDeleteUserRequest *PluginUsermanagerDeleteUserRequest
}

func (r ApiPluginUsermanagerDeleteUserRequest) PluginUsermanagerDeleteUserRequest(pluginUsermanagerDeleteUserRequest PluginUsermanagerDeleteUserRequest) ApiPluginUsermanagerDeleteUserRequest {
	r.pluginUsermanagerDeleteUserRequest = &pluginUsermanagerDeleteUserRequest
	return r
}

func (r ApiPluginUsermanagerDeleteUserRequest) Execute() (*PluginUsermanagerDeleteUser200Response, *http.Response, error) {
	return r.ApiService.PluginUsermanagerDeleteUserExecute(r)
}

/*
PluginUsermanagerDeleteUser Remove a user

You need to be a superuser to delete users.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPluginUsermanagerDeleteUserRequest
*/
func (a *PluginsAPIService) PluginUsermanagerDeleteUser(ctx context.Context) ApiPluginUsermanagerDeleteUserRequest {
	return ApiPluginUsermanagerDeleteUserRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PluginUsermanagerDeleteUser200Response
func (a *PluginsAPIService) PluginUsermanagerDeleteUserExecute(r ApiPluginUsermanagerDeleteUserRequest) (*PluginUsermanagerDeleteUser200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PluginUsermanagerDeleteUser200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.PluginUsermanagerDeleteUser")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/plugin.usermanager.deleteUser"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.pluginUsermanagerDeleteUserRequest == nil {
		return localVarReturnValue, nil, reportError("pluginUsermanagerDeleteUserRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.pluginUsermanagerDeleteUserRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
