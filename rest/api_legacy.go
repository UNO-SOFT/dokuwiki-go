/*
DokuWiki API

The DokuWiki API OpenAPI specification

API version: 14
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package dokuwiki

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// LegacyAPIService LegacyAPI service
type LegacyAPIService service

type ApiDokuwikiAppendPageRequest struct {
	ctx context.Context
	ApiService *LegacyAPIService
	dokuwikiAppendPageRequest *DokuwikiAppendPageRequest
}

func (r ApiDokuwikiAppendPageRequest) DokuwikiAppendPageRequest(dokuwikiAppendPageRequest DokuwikiAppendPageRequest) ApiDokuwikiAppendPageRequest {
	r.dokuwikiAppendPageRequest = &dokuwikiAppendPageRequest
	return r
}

func (r ApiDokuwikiAppendPageRequest) Execute() (*DokuwikiGetVersion200Response, *http.Response, error) {
	return r.ApiService.DokuwikiAppendPageExecute(r)
}

/*
DokuwikiAppendPage dokuwiki.appendPage

**This method is deprecated.** use core.appendPage instead



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDokuwikiAppendPageRequest

Deprecated
*/
func (a *LegacyAPIService) DokuwikiAppendPage(ctx context.Context) ApiDokuwikiAppendPageRequest {
	return ApiDokuwikiAppendPageRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DokuwikiGetVersion200Response
// Deprecated
func (a *LegacyAPIService) DokuwikiAppendPageExecute(r ApiDokuwikiAppendPageRequest) (*DokuwikiGetVersion200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DokuwikiGetVersion200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LegacyAPIService.DokuwikiAppendPage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dokuwiki.appendPage"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.dokuwikiAppendPageRequest == nil {
		return localVarReturnValue, nil, reportError("dokuwikiAppendPageRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.dokuwikiAppendPageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDokuwikiCreateUserRequest struct {
	ctx context.Context
	ApiService *LegacyAPIService
	dokuwikiCreateUserRequest *DokuwikiCreateUserRequest
}

func (r ApiDokuwikiCreateUserRequest) DokuwikiCreateUserRequest(dokuwikiCreateUserRequest DokuwikiCreateUserRequest) ApiDokuwikiCreateUserRequest {
	r.dokuwikiCreateUserRequest = &dokuwikiCreateUserRequest
	return r
}

func (r ApiDokuwikiCreateUserRequest) Execute() (*DokuwikiGetVersion200Response, *http.Response, error) {
	return r.ApiService.DokuwikiCreateUserExecute(r)
}

/*
DokuwikiCreateUser dokuwiki.createUser

**This method is deprecated.** use plugin.usermanager.createUser instead



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDokuwikiCreateUserRequest

Deprecated
*/
func (a *LegacyAPIService) DokuwikiCreateUser(ctx context.Context) ApiDokuwikiCreateUserRequest {
	return ApiDokuwikiCreateUserRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DokuwikiGetVersion200Response
// Deprecated
func (a *LegacyAPIService) DokuwikiCreateUserExecute(r ApiDokuwikiCreateUserRequest) (*DokuwikiGetVersion200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DokuwikiGetVersion200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LegacyAPIService.DokuwikiCreateUser")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dokuwiki.createUser"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.dokuwikiCreateUserRequest == nil {
		return localVarReturnValue, nil, reportError("dokuwikiCreateUserRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.dokuwikiCreateUserRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDokuwikiDeleteUsersRequest struct {
	ctx context.Context
	ApiService *LegacyAPIService
	dokuwikiDeleteUsersRequest *DokuwikiDeleteUsersRequest
}

func (r ApiDokuwikiDeleteUsersRequest) DokuwikiDeleteUsersRequest(dokuwikiDeleteUsersRequest DokuwikiDeleteUsersRequest) ApiDokuwikiDeleteUsersRequest {
	r.dokuwikiDeleteUsersRequest = &dokuwikiDeleteUsersRequest
	return r
}

func (r ApiDokuwikiDeleteUsersRequest) Execute() (*DokuwikiGetVersion200Response, *http.Response, error) {
	return r.ApiService.DokuwikiDeleteUsersExecute(r)
}

/*
DokuwikiDeleteUsers dokuwiki.deleteUsers

**This method is deprecated.** use plugin.usermanager.deleteUser instead



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDokuwikiDeleteUsersRequest

Deprecated
*/
func (a *LegacyAPIService) DokuwikiDeleteUsers(ctx context.Context) ApiDokuwikiDeleteUsersRequest {
	return ApiDokuwikiDeleteUsersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DokuwikiGetVersion200Response
// Deprecated
func (a *LegacyAPIService) DokuwikiDeleteUsersExecute(r ApiDokuwikiDeleteUsersRequest) (*DokuwikiGetVersion200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DokuwikiGetVersion200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LegacyAPIService.DokuwikiDeleteUsers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dokuwiki.deleteUsers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.dokuwikiDeleteUsersRequest == nil {
		return localVarReturnValue, nil, reportError("dokuwikiDeleteUsersRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.dokuwikiDeleteUsersRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDokuwikiGetPagelistRequest struct {
	ctx context.Context
	ApiService *LegacyAPIService
	dokuwikiGetPagelistRequest *DokuwikiGetPagelistRequest
}

func (r ApiDokuwikiGetPagelistRequest) DokuwikiGetPagelistRequest(dokuwikiGetPagelistRequest DokuwikiGetPagelistRequest) ApiDokuwikiGetPagelistRequest {
	r.dokuwikiGetPagelistRequest = &dokuwikiGetPagelistRequest
	return r
}

func (r ApiDokuwikiGetPagelistRequest) Execute() (*DokuwikiGetVersion200Response, *http.Response, error) {
	return r.ApiService.DokuwikiGetPagelistExecute(r)
}

/*
DokuwikiGetPagelist dokuwiki.getPagelist

**This method is deprecated.** use core.listPages instead



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDokuwikiGetPagelistRequest

Deprecated
*/
func (a *LegacyAPIService) DokuwikiGetPagelist(ctx context.Context) ApiDokuwikiGetPagelistRequest {
	return ApiDokuwikiGetPagelistRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DokuwikiGetVersion200Response
// Deprecated
func (a *LegacyAPIService) DokuwikiGetPagelistExecute(r ApiDokuwikiGetPagelistRequest) (*DokuwikiGetVersion200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DokuwikiGetVersion200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LegacyAPIService.DokuwikiGetPagelist")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dokuwiki.getPagelist"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.dokuwikiGetPagelistRequest == nil {
		return localVarReturnValue, nil, reportError("dokuwikiGetPagelistRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.dokuwikiGetPagelistRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDokuwikiGetTimeRequest struct {
	ctx context.Context
	ApiService *LegacyAPIService
	body *nil
}

func (r ApiDokuwikiGetTimeRequest) Body(body nil) ApiDokuwikiGetTimeRequest {
	r.body = &body
	return r
}

func (r ApiDokuwikiGetTimeRequest) Execute() (*DokuwikiGetVersion200Response, *http.Response, error) {
	return r.ApiService.DokuwikiGetTimeExecute(r)
}

/*
DokuwikiGetTime dokuwiki.getTime

**This method is deprecated.** use core.getWikiTime instead



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDokuwikiGetTimeRequest

Deprecated
*/
func (a *LegacyAPIService) DokuwikiGetTime(ctx context.Context) ApiDokuwikiGetTimeRequest {
	return ApiDokuwikiGetTimeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DokuwikiGetVersion200Response
// Deprecated
func (a *LegacyAPIService) DokuwikiGetTimeExecute(r ApiDokuwikiGetTimeRequest) (*DokuwikiGetVersion200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DokuwikiGetVersion200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LegacyAPIService.DokuwikiGetTime")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dokuwiki.getTime"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDokuwikiGetTitleRequest struct {
	ctx context.Context
	ApiService *LegacyAPIService
	body *nil
}

func (r ApiDokuwikiGetTitleRequest) Body(body nil) ApiDokuwikiGetTitleRequest {
	r.body = &body
	return r
}

func (r ApiDokuwikiGetTitleRequest) Execute() (*DokuwikiGetVersion200Response, *http.Response, error) {
	return r.ApiService.DokuwikiGetTitleExecute(r)
}

/*
DokuwikiGetTitle dokuwiki.getTitle

**This method is deprecated.** use core.getWikiTitle instead

This method is public and does not require authentication. 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDokuwikiGetTitleRequest

Deprecated
*/
func (a *LegacyAPIService) DokuwikiGetTitle(ctx context.Context) ApiDokuwikiGetTitleRequest {
	return ApiDokuwikiGetTitleRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DokuwikiGetVersion200Response
// Deprecated
func (a *LegacyAPIService) DokuwikiGetTitleExecute(r ApiDokuwikiGetTitleRequest) (*DokuwikiGetVersion200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DokuwikiGetVersion200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LegacyAPIService.DokuwikiGetTitle")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dokuwiki.getTitle"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDokuwikiGetVersionRequest struct {
	ctx context.Context
	ApiService *LegacyAPIService
	body *nil
}

func (r ApiDokuwikiGetVersionRequest) Body(body nil) ApiDokuwikiGetVersionRequest {
	r.body = &body
	return r
}

func (r ApiDokuwikiGetVersionRequest) Execute() (*DokuwikiGetVersion200Response, *http.Response, error) {
	return r.ApiService.DokuwikiGetVersionExecute(r)
}

/*
DokuwikiGetVersion dokuwiki.getVersion

**This method is deprecated.** use core.getWikiVersion instead



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDokuwikiGetVersionRequest

Deprecated
*/
func (a *LegacyAPIService) DokuwikiGetVersion(ctx context.Context) ApiDokuwikiGetVersionRequest {
	return ApiDokuwikiGetVersionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DokuwikiGetVersion200Response
// Deprecated
func (a *LegacyAPIService) DokuwikiGetVersionExecute(r ApiDokuwikiGetVersionRequest) (*DokuwikiGetVersion200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DokuwikiGetVersion200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LegacyAPIService.DokuwikiGetVersion")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dokuwiki.getVersion"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDokuwikiGetXMLRPCAPIVersionRequest struct {
	ctx context.Context
	ApiService *LegacyAPIService
	body *nil
}

func (r ApiDokuwikiGetXMLRPCAPIVersionRequest) Body(body nil) ApiDokuwikiGetXMLRPCAPIVersionRequest {
	r.body = &body
	return r
}

func (r ApiDokuwikiGetXMLRPCAPIVersionRequest) Execute() (*DokuwikiGetVersion200Response, *http.Response, error) {
	return r.ApiService.DokuwikiGetXMLRPCAPIVersionExecute(r)
}

/*
DokuwikiGetXMLRPCAPIVersion dokuwiki.getXMLRPCAPIVersion

**This method is deprecated.** use core.getAPIVersion instead

This method is public and does not require authentication. 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDokuwikiGetXMLRPCAPIVersionRequest

Deprecated
*/
func (a *LegacyAPIService) DokuwikiGetXMLRPCAPIVersion(ctx context.Context) ApiDokuwikiGetXMLRPCAPIVersionRequest {
	return ApiDokuwikiGetXMLRPCAPIVersionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DokuwikiGetVersion200Response
// Deprecated
func (a *LegacyAPIService) DokuwikiGetXMLRPCAPIVersionExecute(r ApiDokuwikiGetXMLRPCAPIVersionRequest) (*DokuwikiGetVersion200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DokuwikiGetVersion200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LegacyAPIService.DokuwikiGetXMLRPCAPIVersion")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dokuwiki.getXMLRPCAPIVersion"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDokuwikiLoginRequest struct {
	ctx context.Context
	ApiService *LegacyAPIService
	dokuwikiLoginRequest *DokuwikiLoginRequest
}

func (r ApiDokuwikiLoginRequest) DokuwikiLoginRequest(dokuwikiLoginRequest DokuwikiLoginRequest) ApiDokuwikiLoginRequest {
	r.dokuwikiLoginRequest = &dokuwikiLoginRequest
	return r
}

func (r ApiDokuwikiLoginRequest) Execute() (*DokuwikiGetVersion200Response, *http.Response, error) {
	return r.ApiService.DokuwikiLoginExecute(r)
}

/*
DokuwikiLogin dokuwiki.login

**This method is deprecated.** use core.login instead

This method is public and does not require authentication. 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDokuwikiLoginRequest

Deprecated
*/
func (a *LegacyAPIService) DokuwikiLogin(ctx context.Context) ApiDokuwikiLoginRequest {
	return ApiDokuwikiLoginRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DokuwikiGetVersion200Response
// Deprecated
func (a *LegacyAPIService) DokuwikiLoginExecute(r ApiDokuwikiLoginRequest) (*DokuwikiGetVersion200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DokuwikiGetVersion200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LegacyAPIService.DokuwikiLogin")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dokuwiki.login"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.dokuwikiLoginRequest == nil {
		return localVarReturnValue, nil, reportError("dokuwikiLoginRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.dokuwikiLoginRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDokuwikiLogoffRequest struct {
	ctx context.Context
	ApiService *LegacyAPIService
	body *nil
}

func (r ApiDokuwikiLogoffRequest) Body(body nil) ApiDokuwikiLogoffRequest {
	r.body = &body
	return r
}

func (r ApiDokuwikiLogoffRequest) Execute() (*DokuwikiGetVersion200Response, *http.Response, error) {
	return r.ApiService.DokuwikiLogoffExecute(r)
}

/*
DokuwikiLogoff dokuwiki.logoff

**This method is deprecated.** use core.logoff instead



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDokuwikiLogoffRequest

Deprecated
*/
func (a *LegacyAPIService) DokuwikiLogoff(ctx context.Context) ApiDokuwikiLogoffRequest {
	return ApiDokuwikiLogoffRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DokuwikiGetVersion200Response
// Deprecated
func (a *LegacyAPIService) DokuwikiLogoffExecute(r ApiDokuwikiLogoffRequest) (*DokuwikiGetVersion200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DokuwikiGetVersion200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LegacyAPIService.DokuwikiLogoff")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dokuwiki.logoff"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDokuwikiSearchRequest struct {
	ctx context.Context
	ApiService *LegacyAPIService
	dokuwikiSearchRequest *DokuwikiSearchRequest
}

func (r ApiDokuwikiSearchRequest) DokuwikiSearchRequest(dokuwikiSearchRequest DokuwikiSearchRequest) ApiDokuwikiSearchRequest {
	r.dokuwikiSearchRequest = &dokuwikiSearchRequest
	return r
}

func (r ApiDokuwikiSearchRequest) Execute() (*DokuwikiGetVersion200Response, *http.Response, error) {
	return r.ApiService.DokuwikiSearchExecute(r)
}

/*
DokuwikiSearch dokuwiki.search

**This method is deprecated.** use core.searchPages instead



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDokuwikiSearchRequest

Deprecated
*/
func (a *LegacyAPIService) DokuwikiSearch(ctx context.Context) ApiDokuwikiSearchRequest {
	return ApiDokuwikiSearchRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DokuwikiGetVersion200Response
// Deprecated
func (a *LegacyAPIService) DokuwikiSearchExecute(r ApiDokuwikiSearchRequest) (*DokuwikiGetVersion200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DokuwikiGetVersion200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LegacyAPIService.DokuwikiSearch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dokuwiki.search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.dokuwikiSearchRequest == nil {
		return localVarReturnValue, nil, reportError("dokuwikiSearchRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.dokuwikiSearchRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDokuwikiSetLocksRequest struct {
	ctx context.Context
	ApiService *LegacyAPIService
	dokuwikiSetLocksRequest *DokuwikiSetLocksRequest
}

func (r ApiDokuwikiSetLocksRequest) DokuwikiSetLocksRequest(dokuwikiSetLocksRequest DokuwikiSetLocksRequest) ApiDokuwikiSetLocksRequest {
	r.dokuwikiSetLocksRequest = &dokuwikiSetLocksRequest
	return r
}

func (r ApiDokuwikiSetLocksRequest) Execute() (*DokuwikiGetVersion200Response, *http.Response, error) {
	return r.ApiService.DokuwikiSetLocksExecute(r)
}

/*
DokuwikiSetLocks dokuwiki.setLocks

**This method is deprecated.** use core.lockPages and core.unlockPages instead



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDokuwikiSetLocksRequest

Deprecated
*/
func (a *LegacyAPIService) DokuwikiSetLocks(ctx context.Context) ApiDokuwikiSetLocksRequest {
	return ApiDokuwikiSetLocksRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DokuwikiGetVersion200Response
// Deprecated
func (a *LegacyAPIService) DokuwikiSetLocksExecute(r ApiDokuwikiSetLocksRequest) (*DokuwikiGetVersion200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DokuwikiGetVersion200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LegacyAPIService.DokuwikiSetLocks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dokuwiki.setLocks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.dokuwikiSetLocksRequest == nil {
		return localVarReturnValue, nil, reportError("dokuwikiSetLocksRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.dokuwikiSetLocksRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWikiAclCheckRequest struct {
	ctx context.Context
	ApiService *LegacyAPIService
	wikiAclCheckRequest *WikiAclCheckRequest
}

func (r ApiWikiAclCheckRequest) WikiAclCheckRequest(wikiAclCheckRequest WikiAclCheckRequest) ApiWikiAclCheckRequest {
	r.wikiAclCheckRequest = &wikiAclCheckRequest
	return r
}

func (r ApiWikiAclCheckRequest) Execute() (*DokuwikiGetVersion200Response, *http.Response, error) {
	return r.ApiService.WikiAclCheckExecute(r)
}

/*
WikiAclCheck wiki.aclCheck

**This method is deprecated.** use core.aclCheck instead



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiWikiAclCheckRequest

Deprecated
*/
func (a *LegacyAPIService) WikiAclCheck(ctx context.Context) ApiWikiAclCheckRequest {
	return ApiWikiAclCheckRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DokuwikiGetVersion200Response
// Deprecated
func (a *LegacyAPIService) WikiAclCheckExecute(r ApiWikiAclCheckRequest) (*DokuwikiGetVersion200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DokuwikiGetVersion200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LegacyAPIService.WikiAclCheck")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/wiki.aclCheck"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.wikiAclCheckRequest == nil {
		return localVarReturnValue, nil, reportError("wikiAclCheckRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.wikiAclCheckRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWikiDeleteAttachmentRequest struct {
	ctx context.Context
	ApiService *LegacyAPIService
	wikiGetPageRequest *WikiGetPageRequest
}

func (r ApiWikiDeleteAttachmentRequest) WikiGetPageRequest(wikiGetPageRequest WikiGetPageRequest) ApiWikiDeleteAttachmentRequest {
	r.wikiGetPageRequest = &wikiGetPageRequest
	return r
}

func (r ApiWikiDeleteAttachmentRequest) Execute() (*DokuwikiGetVersion200Response, *http.Response, error) {
	return r.ApiService.WikiDeleteAttachmentExecute(r)
}

/*
WikiDeleteAttachment wiki.deleteAttachment

**This method is deprecated.** use core.deleteMedia instead



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiWikiDeleteAttachmentRequest

Deprecated
*/
func (a *LegacyAPIService) WikiDeleteAttachment(ctx context.Context) ApiWikiDeleteAttachmentRequest {
	return ApiWikiDeleteAttachmentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DokuwikiGetVersion200Response
// Deprecated
func (a *LegacyAPIService) WikiDeleteAttachmentExecute(r ApiWikiDeleteAttachmentRequest) (*DokuwikiGetVersion200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DokuwikiGetVersion200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LegacyAPIService.WikiDeleteAttachment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/wiki.deleteAttachment"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.wikiGetPageRequest == nil {
		return localVarReturnValue, nil, reportError("wikiGetPageRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.wikiGetPageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWikiGetAllPagesRequest struct {
	ctx context.Context
	ApiService *LegacyAPIService
	body *nil
}

func (r ApiWikiGetAllPagesRequest) Body(body nil) ApiWikiGetAllPagesRequest {
	r.body = &body
	return r
}

func (r ApiWikiGetAllPagesRequest) Execute() (*DokuwikiGetVersion200Response, *http.Response, error) {
	return r.ApiService.WikiGetAllPagesExecute(r)
}

/*
WikiGetAllPages wiki.getAllPages

**This method is deprecated.** use core.listPages instead



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiWikiGetAllPagesRequest

Deprecated
*/
func (a *LegacyAPIService) WikiGetAllPages(ctx context.Context) ApiWikiGetAllPagesRequest {
	return ApiWikiGetAllPagesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DokuwikiGetVersion200Response
// Deprecated
func (a *LegacyAPIService) WikiGetAllPagesExecute(r ApiWikiGetAllPagesRequest) (*DokuwikiGetVersion200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DokuwikiGetVersion200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LegacyAPIService.WikiGetAllPages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/wiki.getAllPages"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWikiGetAttachmentRequest struct {
	ctx context.Context
	ApiService *LegacyAPIService
	wikiGetPageRequest *WikiGetPageRequest
}

func (r ApiWikiGetAttachmentRequest) WikiGetPageRequest(wikiGetPageRequest WikiGetPageRequest) ApiWikiGetAttachmentRequest {
	r.wikiGetPageRequest = &wikiGetPageRequest
	return r
}

func (r ApiWikiGetAttachmentRequest) Execute() (*DokuwikiGetVersion200Response, *http.Response, error) {
	return r.ApiService.WikiGetAttachmentExecute(r)
}

/*
WikiGetAttachment wiki.getAttachment

**This method is deprecated.** use core.getMedia instead



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiWikiGetAttachmentRequest

Deprecated
*/
func (a *LegacyAPIService) WikiGetAttachment(ctx context.Context) ApiWikiGetAttachmentRequest {
	return ApiWikiGetAttachmentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DokuwikiGetVersion200Response
// Deprecated
func (a *LegacyAPIService) WikiGetAttachmentExecute(r ApiWikiGetAttachmentRequest) (*DokuwikiGetVersion200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DokuwikiGetVersion200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LegacyAPIService.WikiGetAttachment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/wiki.getAttachment"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.wikiGetPageRequest == nil {
		return localVarReturnValue, nil, reportError("wikiGetPageRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.wikiGetPageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWikiGetAttachmentInfoRequest struct {
	ctx context.Context
	ApiService *LegacyAPIService
	wikiGetPageRequest *WikiGetPageRequest
}

func (r ApiWikiGetAttachmentInfoRequest) WikiGetPageRequest(wikiGetPageRequest WikiGetPageRequest) ApiWikiGetAttachmentInfoRequest {
	r.wikiGetPageRequest = &wikiGetPageRequest
	return r
}

func (r ApiWikiGetAttachmentInfoRequest) Execute() (*DokuwikiGetVersion200Response, *http.Response, error) {
	return r.ApiService.WikiGetAttachmentInfoExecute(r)
}

/*
WikiGetAttachmentInfo wiki.getAttachmentInfo

**This method is deprecated.** use core.getMediaInfo instead



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiWikiGetAttachmentInfoRequest

Deprecated
*/
func (a *LegacyAPIService) WikiGetAttachmentInfo(ctx context.Context) ApiWikiGetAttachmentInfoRequest {
	return ApiWikiGetAttachmentInfoRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DokuwikiGetVersion200Response
// Deprecated
func (a *LegacyAPIService) WikiGetAttachmentInfoExecute(r ApiWikiGetAttachmentInfoRequest) (*DokuwikiGetVersion200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DokuwikiGetVersion200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LegacyAPIService.WikiGetAttachmentInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/wiki.getAttachmentInfo"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.wikiGetPageRequest == nil {
		return localVarReturnValue, nil, reportError("wikiGetPageRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.wikiGetPageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWikiGetAttachmentsRequest struct {
	ctx context.Context
	ApiService *LegacyAPIService
	wikiGetAttachmentsRequest *WikiGetAttachmentsRequest
}

func (r ApiWikiGetAttachmentsRequest) WikiGetAttachmentsRequest(wikiGetAttachmentsRequest WikiGetAttachmentsRequest) ApiWikiGetAttachmentsRequest {
	r.wikiGetAttachmentsRequest = &wikiGetAttachmentsRequest
	return r
}

func (r ApiWikiGetAttachmentsRequest) Execute() (*DokuwikiGetVersion200Response, *http.Response, error) {
	return r.ApiService.WikiGetAttachmentsExecute(r)
}

/*
WikiGetAttachments wiki.getAttachments

**This method is deprecated.** use core.listMedia instead



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiWikiGetAttachmentsRequest

Deprecated
*/
func (a *LegacyAPIService) WikiGetAttachments(ctx context.Context) ApiWikiGetAttachmentsRequest {
	return ApiWikiGetAttachmentsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DokuwikiGetVersion200Response
// Deprecated
func (a *LegacyAPIService) WikiGetAttachmentsExecute(r ApiWikiGetAttachmentsRequest) (*DokuwikiGetVersion200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DokuwikiGetVersion200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LegacyAPIService.WikiGetAttachments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/wiki.getAttachments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.wikiGetAttachmentsRequest == nil {
		return localVarReturnValue, nil, reportError("wikiGetAttachmentsRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.wikiGetAttachmentsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWikiGetBackLinksRequest struct {
	ctx context.Context
	ApiService *LegacyAPIService
	wikiGetPageRequest *WikiGetPageRequest
}

func (r ApiWikiGetBackLinksRequest) WikiGetPageRequest(wikiGetPageRequest WikiGetPageRequest) ApiWikiGetBackLinksRequest {
	r.wikiGetPageRequest = &wikiGetPageRequest
	return r
}

func (r ApiWikiGetBackLinksRequest) Execute() (*DokuwikiGetVersion200Response, *http.Response, error) {
	return r.ApiService.WikiGetBackLinksExecute(r)
}

/*
WikiGetBackLinks wiki.getBackLinks

**This method is deprecated.** use core.getPageBackLinks instead



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiWikiGetBackLinksRequest

Deprecated
*/
func (a *LegacyAPIService) WikiGetBackLinks(ctx context.Context) ApiWikiGetBackLinksRequest {
	return ApiWikiGetBackLinksRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DokuwikiGetVersion200Response
// Deprecated
func (a *LegacyAPIService) WikiGetBackLinksExecute(r ApiWikiGetBackLinksRequest) (*DokuwikiGetVersion200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DokuwikiGetVersion200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LegacyAPIService.WikiGetBackLinks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/wiki.getBackLinks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.wikiGetPageRequest == nil {
		return localVarReturnValue, nil, reportError("wikiGetPageRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.wikiGetPageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWikiGetPageRequest struct {
	ctx context.Context
	ApiService *LegacyAPIService
	wikiGetPageRequest *WikiGetPageRequest
}

func (r ApiWikiGetPageRequest) WikiGetPageRequest(wikiGetPageRequest WikiGetPageRequest) ApiWikiGetPageRequest {
	r.wikiGetPageRequest = &wikiGetPageRequest
	return r
}

func (r ApiWikiGetPageRequest) Execute() (*DokuwikiGetVersion200Response, *http.Response, error) {
	return r.ApiService.WikiGetPageExecute(r)
}

/*
WikiGetPage wiki.getPage

**This method is deprecated.** use core.getPage instead



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiWikiGetPageRequest

Deprecated
*/
func (a *LegacyAPIService) WikiGetPage(ctx context.Context) ApiWikiGetPageRequest {
	return ApiWikiGetPageRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DokuwikiGetVersion200Response
// Deprecated
func (a *LegacyAPIService) WikiGetPageExecute(r ApiWikiGetPageRequest) (*DokuwikiGetVersion200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DokuwikiGetVersion200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LegacyAPIService.WikiGetPage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/wiki.getPage"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.wikiGetPageRequest == nil {
		return localVarReturnValue, nil, reportError("wikiGetPageRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.wikiGetPageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWikiGetPageHTMLRequest struct {
	ctx context.Context
	ApiService *LegacyAPIService
	wikiGetPageRequest *WikiGetPageRequest
}

func (r ApiWikiGetPageHTMLRequest) WikiGetPageRequest(wikiGetPageRequest WikiGetPageRequest) ApiWikiGetPageHTMLRequest {
	r.wikiGetPageRequest = &wikiGetPageRequest
	return r
}

func (r ApiWikiGetPageHTMLRequest) Execute() (*DokuwikiGetVersion200Response, *http.Response, error) {
	return r.ApiService.WikiGetPageHTMLExecute(r)
}

/*
WikiGetPageHTML wiki.getPageHTML

**This method is deprecated.** use core.getPageHTML instead



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiWikiGetPageHTMLRequest

Deprecated
*/
func (a *LegacyAPIService) WikiGetPageHTML(ctx context.Context) ApiWikiGetPageHTMLRequest {
	return ApiWikiGetPageHTMLRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DokuwikiGetVersion200Response
// Deprecated
func (a *LegacyAPIService) WikiGetPageHTMLExecute(r ApiWikiGetPageHTMLRequest) (*DokuwikiGetVersion200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DokuwikiGetVersion200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LegacyAPIService.WikiGetPageHTML")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/wiki.getPageHTML"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.wikiGetPageRequest == nil {
		return localVarReturnValue, nil, reportError("wikiGetPageRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.wikiGetPageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWikiGetPageHTMLVersionRequest struct {
	ctx context.Context
	ApiService *LegacyAPIService
	wikiGetPageVersionRequest *WikiGetPageVersionRequest
}

func (r ApiWikiGetPageHTMLVersionRequest) WikiGetPageVersionRequest(wikiGetPageVersionRequest WikiGetPageVersionRequest) ApiWikiGetPageHTMLVersionRequest {
	r.wikiGetPageVersionRequest = &wikiGetPageVersionRequest
	return r
}

func (r ApiWikiGetPageHTMLVersionRequest) Execute() (*DokuwikiGetVersion200Response, *http.Response, error) {
	return r.ApiService.WikiGetPageHTMLVersionExecute(r)
}

/*
WikiGetPageHTMLVersion wiki.getPageHTMLVersion

**This method is deprecated.** use core.getPageHTML instead



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiWikiGetPageHTMLVersionRequest

Deprecated
*/
func (a *LegacyAPIService) WikiGetPageHTMLVersion(ctx context.Context) ApiWikiGetPageHTMLVersionRequest {
	return ApiWikiGetPageHTMLVersionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DokuwikiGetVersion200Response
// Deprecated
func (a *LegacyAPIService) WikiGetPageHTMLVersionExecute(r ApiWikiGetPageHTMLVersionRequest) (*DokuwikiGetVersion200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DokuwikiGetVersion200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LegacyAPIService.WikiGetPageHTMLVersion")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/wiki.getPageHTMLVersion"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.wikiGetPageVersionRequest == nil {
		return localVarReturnValue, nil, reportError("wikiGetPageVersionRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.wikiGetPageVersionRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWikiGetPageInfoRequest struct {
	ctx context.Context
	ApiService *LegacyAPIService
	wikiGetPageRequest *WikiGetPageRequest
}

func (r ApiWikiGetPageInfoRequest) WikiGetPageRequest(wikiGetPageRequest WikiGetPageRequest) ApiWikiGetPageInfoRequest {
	r.wikiGetPageRequest = &wikiGetPageRequest
	return r
}

func (r ApiWikiGetPageInfoRequest) Execute() (*DokuwikiGetVersion200Response, *http.Response, error) {
	return r.ApiService.WikiGetPageInfoExecute(r)
}

/*
WikiGetPageInfo wiki.getPageInfo

**This method is deprecated.** use core.getPageInfo instead



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiWikiGetPageInfoRequest

Deprecated
*/
func (a *LegacyAPIService) WikiGetPageInfo(ctx context.Context) ApiWikiGetPageInfoRequest {
	return ApiWikiGetPageInfoRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DokuwikiGetVersion200Response
// Deprecated
func (a *LegacyAPIService) WikiGetPageInfoExecute(r ApiWikiGetPageInfoRequest) (*DokuwikiGetVersion200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DokuwikiGetVersion200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LegacyAPIService.WikiGetPageInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/wiki.getPageInfo"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.wikiGetPageRequest == nil {
		return localVarReturnValue, nil, reportError("wikiGetPageRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.wikiGetPageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWikiGetPageInfoVersionRequest struct {
	ctx context.Context
	ApiService *LegacyAPIService
	wikiGetPageVersionRequest *WikiGetPageVersionRequest
}

func (r ApiWikiGetPageInfoVersionRequest) WikiGetPageVersionRequest(wikiGetPageVersionRequest WikiGetPageVersionRequest) ApiWikiGetPageInfoVersionRequest {
	r.wikiGetPageVersionRequest = &wikiGetPageVersionRequest
	return r
}

func (r ApiWikiGetPageInfoVersionRequest) Execute() (*DokuwikiGetVersion200Response, *http.Response, error) {
	return r.ApiService.WikiGetPageInfoVersionExecute(r)
}

/*
WikiGetPageInfoVersion wiki.getPageInfoVersion

**This method is deprecated.** use core.getPageInfo instead



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiWikiGetPageInfoVersionRequest

Deprecated
*/
func (a *LegacyAPIService) WikiGetPageInfoVersion(ctx context.Context) ApiWikiGetPageInfoVersionRequest {
	return ApiWikiGetPageInfoVersionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DokuwikiGetVersion200Response
// Deprecated
func (a *LegacyAPIService) WikiGetPageInfoVersionExecute(r ApiWikiGetPageInfoVersionRequest) (*DokuwikiGetVersion200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DokuwikiGetVersion200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LegacyAPIService.WikiGetPageInfoVersion")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/wiki.getPageInfoVersion"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.wikiGetPageVersionRequest == nil {
		return localVarReturnValue, nil, reportError("wikiGetPageVersionRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.wikiGetPageVersionRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWikiGetPageVersionRequest struct {
	ctx context.Context
	ApiService *LegacyAPIService
	wikiGetPageVersionRequest *WikiGetPageVersionRequest
}

func (r ApiWikiGetPageVersionRequest) WikiGetPageVersionRequest(wikiGetPageVersionRequest WikiGetPageVersionRequest) ApiWikiGetPageVersionRequest {
	r.wikiGetPageVersionRequest = &wikiGetPageVersionRequest
	return r
}

func (r ApiWikiGetPageVersionRequest) Execute() (*DokuwikiGetVersion200Response, *http.Response, error) {
	return r.ApiService.WikiGetPageVersionExecute(r)
}

/*
WikiGetPageVersion wiki.getPageVersion

**This method is deprecated.** use core.getPage instead



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiWikiGetPageVersionRequest

Deprecated
*/
func (a *LegacyAPIService) WikiGetPageVersion(ctx context.Context) ApiWikiGetPageVersionRequest {
	return ApiWikiGetPageVersionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DokuwikiGetVersion200Response
// Deprecated
func (a *LegacyAPIService) WikiGetPageVersionExecute(r ApiWikiGetPageVersionRequest) (*DokuwikiGetVersion200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DokuwikiGetVersion200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LegacyAPIService.WikiGetPageVersion")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/wiki.getPageVersion"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.wikiGetPageVersionRequest == nil {
		return localVarReturnValue, nil, reportError("wikiGetPageVersionRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.wikiGetPageVersionRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWikiGetPageVersionsRequest struct {
	ctx context.Context
	ApiService *LegacyAPIService
	wikiGetPageVersionsRequest *WikiGetPageVersionsRequest
}

func (r ApiWikiGetPageVersionsRequest) WikiGetPageVersionsRequest(wikiGetPageVersionsRequest WikiGetPageVersionsRequest) ApiWikiGetPageVersionsRequest {
	r.wikiGetPageVersionsRequest = &wikiGetPageVersionsRequest
	return r
}

func (r ApiWikiGetPageVersionsRequest) Execute() (*DokuwikiGetVersion200Response, *http.Response, error) {
	return r.ApiService.WikiGetPageVersionsExecute(r)
}

/*
WikiGetPageVersions wiki.getPageVersions

**This method is deprecated.** use core.getPageHistory instead



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiWikiGetPageVersionsRequest

Deprecated
*/
func (a *LegacyAPIService) WikiGetPageVersions(ctx context.Context) ApiWikiGetPageVersionsRequest {
	return ApiWikiGetPageVersionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DokuwikiGetVersion200Response
// Deprecated
func (a *LegacyAPIService) WikiGetPageVersionsExecute(r ApiWikiGetPageVersionsRequest) (*DokuwikiGetVersion200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DokuwikiGetVersion200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LegacyAPIService.WikiGetPageVersions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/wiki.getPageVersions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.wikiGetPageVersionsRequest == nil {
		return localVarReturnValue, nil, reportError("wikiGetPageVersionsRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.wikiGetPageVersionsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWikiGetRPCVersionSupportedRequest struct {
	ctx context.Context
	ApiService *LegacyAPIService
	body *nil
}

func (r ApiWikiGetRPCVersionSupportedRequest) Body(body nil) ApiWikiGetRPCVersionSupportedRequest {
	r.body = &body
	return r
}

func (r ApiWikiGetRPCVersionSupportedRequest) Execute() (*DokuwikiGetVersion200Response, *http.Response, error) {
	return r.ApiService.WikiGetRPCVersionSupportedExecute(r)
}

/*
WikiGetRPCVersionSupported wiki.getRPCVersionSupported

**This method is deprecated.** Wiki RPC spec is no longer supported

This method is public and does not require authentication. 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiWikiGetRPCVersionSupportedRequest

Deprecated
*/
func (a *LegacyAPIService) WikiGetRPCVersionSupported(ctx context.Context) ApiWikiGetRPCVersionSupportedRequest {
	return ApiWikiGetRPCVersionSupportedRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DokuwikiGetVersion200Response
// Deprecated
func (a *LegacyAPIService) WikiGetRPCVersionSupportedExecute(r ApiWikiGetRPCVersionSupportedRequest) (*DokuwikiGetVersion200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DokuwikiGetVersion200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LegacyAPIService.WikiGetRPCVersionSupported")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/wiki.getRPCVersionSupported"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWikiGetRecentChangesRequest struct {
	ctx context.Context
	ApiService *LegacyAPIService
	wikiGetRecentChangesRequest *WikiGetRecentChangesRequest
}

func (r ApiWikiGetRecentChangesRequest) WikiGetRecentChangesRequest(wikiGetRecentChangesRequest WikiGetRecentChangesRequest) ApiWikiGetRecentChangesRequest {
	r.wikiGetRecentChangesRequest = &wikiGetRecentChangesRequest
	return r
}

func (r ApiWikiGetRecentChangesRequest) Execute() (*DokuwikiGetVersion200Response, *http.Response, error) {
	return r.ApiService.WikiGetRecentChangesExecute(r)
}

/*
WikiGetRecentChanges wiki.getRecentChanges

**This method is deprecated.** use core.getRecentChanges instead



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiWikiGetRecentChangesRequest

Deprecated
*/
func (a *LegacyAPIService) WikiGetRecentChanges(ctx context.Context) ApiWikiGetRecentChangesRequest {
	return ApiWikiGetRecentChangesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DokuwikiGetVersion200Response
// Deprecated
func (a *LegacyAPIService) WikiGetRecentChangesExecute(r ApiWikiGetRecentChangesRequest) (*DokuwikiGetVersion200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DokuwikiGetVersion200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LegacyAPIService.WikiGetRecentChanges")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/wiki.getRecentChanges"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.wikiGetRecentChangesRequest == nil {
		return localVarReturnValue, nil, reportError("wikiGetRecentChangesRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.wikiGetRecentChangesRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWikiGetRecentMediaChangesRequest struct {
	ctx context.Context
	ApiService *LegacyAPIService
	wikiGetRecentChangesRequest *WikiGetRecentChangesRequest
}

func (r ApiWikiGetRecentMediaChangesRequest) WikiGetRecentChangesRequest(wikiGetRecentChangesRequest WikiGetRecentChangesRequest) ApiWikiGetRecentMediaChangesRequest {
	r.wikiGetRecentChangesRequest = &wikiGetRecentChangesRequest
	return r
}

func (r ApiWikiGetRecentMediaChangesRequest) Execute() (*DokuwikiGetVersion200Response, *http.Response, error) {
	return r.ApiService.WikiGetRecentMediaChangesExecute(r)
}

/*
WikiGetRecentMediaChanges wiki.getRecentMediaChanges

**This method is deprecated.** use core.getRecentMediaChanges instead



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiWikiGetRecentMediaChangesRequest

Deprecated
*/
func (a *LegacyAPIService) WikiGetRecentMediaChanges(ctx context.Context) ApiWikiGetRecentMediaChangesRequest {
	return ApiWikiGetRecentMediaChangesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DokuwikiGetVersion200Response
// Deprecated
func (a *LegacyAPIService) WikiGetRecentMediaChangesExecute(r ApiWikiGetRecentMediaChangesRequest) (*DokuwikiGetVersion200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DokuwikiGetVersion200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LegacyAPIService.WikiGetRecentMediaChanges")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/wiki.getRecentMediaChanges"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.wikiGetRecentChangesRequest == nil {
		return localVarReturnValue, nil, reportError("wikiGetRecentChangesRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.wikiGetRecentChangesRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWikiListLinksRequest struct {
	ctx context.Context
	ApiService *LegacyAPIService
	wikiGetPageRequest *WikiGetPageRequest
}

func (r ApiWikiListLinksRequest) WikiGetPageRequest(wikiGetPageRequest WikiGetPageRequest) ApiWikiListLinksRequest {
	r.wikiGetPageRequest = &wikiGetPageRequest
	return r
}

func (r ApiWikiListLinksRequest) Execute() (*DokuwikiGetVersion200Response, *http.Response, error) {
	return r.ApiService.WikiListLinksExecute(r)
}

/*
WikiListLinks wiki.listLinks

**This method is deprecated.** use core.listLinks instead



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiWikiListLinksRequest

Deprecated
*/
func (a *LegacyAPIService) WikiListLinks(ctx context.Context) ApiWikiListLinksRequest {
	return ApiWikiListLinksRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DokuwikiGetVersion200Response
// Deprecated
func (a *LegacyAPIService) WikiListLinksExecute(r ApiWikiListLinksRequest) (*DokuwikiGetVersion200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DokuwikiGetVersion200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LegacyAPIService.WikiListLinks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/wiki.listLinks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.wikiGetPageRequest == nil {
		return localVarReturnValue, nil, reportError("wikiGetPageRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.wikiGetPageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWikiPutAttachmentRequest struct {
	ctx context.Context
	ApiService *LegacyAPIService
	wikiPutAttachmentRequest *WikiPutAttachmentRequest
}

func (r ApiWikiPutAttachmentRequest) WikiPutAttachmentRequest(wikiPutAttachmentRequest WikiPutAttachmentRequest) ApiWikiPutAttachmentRequest {
	r.wikiPutAttachmentRequest = &wikiPutAttachmentRequest
	return r
}

func (r ApiWikiPutAttachmentRequest) Execute() (*DokuwikiGetVersion200Response, *http.Response, error) {
	return r.ApiService.WikiPutAttachmentExecute(r)
}

/*
WikiPutAttachment wiki.putAttachment

**This method is deprecated.** use core.saveMedia instead



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiWikiPutAttachmentRequest

Deprecated
*/
func (a *LegacyAPIService) WikiPutAttachment(ctx context.Context) ApiWikiPutAttachmentRequest {
	return ApiWikiPutAttachmentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DokuwikiGetVersion200Response
// Deprecated
func (a *LegacyAPIService) WikiPutAttachmentExecute(r ApiWikiPutAttachmentRequest) (*DokuwikiGetVersion200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DokuwikiGetVersion200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LegacyAPIService.WikiPutAttachment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/wiki.putAttachment"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.wikiPutAttachmentRequest == nil {
		return localVarReturnValue, nil, reportError("wikiPutAttachmentRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.wikiPutAttachmentRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWikiPutPageRequest struct {
	ctx context.Context
	ApiService *LegacyAPIService
	dokuwikiAppendPageRequest *DokuwikiAppendPageRequest
}

func (r ApiWikiPutPageRequest) DokuwikiAppendPageRequest(dokuwikiAppendPageRequest DokuwikiAppendPageRequest) ApiWikiPutPageRequest {
	r.dokuwikiAppendPageRequest = &dokuwikiAppendPageRequest
	return r
}

func (r ApiWikiPutPageRequest) Execute() (*DokuwikiGetVersion200Response, *http.Response, error) {
	return r.ApiService.WikiPutPageExecute(r)
}

/*
WikiPutPage wiki.putPage

**This method is deprecated.** use core.savePage instead



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiWikiPutPageRequest

Deprecated
*/
func (a *LegacyAPIService) WikiPutPage(ctx context.Context) ApiWikiPutPageRequest {
	return ApiWikiPutPageRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DokuwikiGetVersion200Response
// Deprecated
func (a *LegacyAPIService) WikiPutPageExecute(r ApiWikiPutPageRequest) (*DokuwikiGetVersion200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DokuwikiGetVersion200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LegacyAPIService.WikiPutPage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/wiki.putPage"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.dokuwikiAppendPageRequest == nil {
		return localVarReturnValue, nil, reportError("dokuwikiAppendPageRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.dokuwikiAppendPageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
