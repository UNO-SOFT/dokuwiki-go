/*
DokuWiki API

The DokuWiki API OpenAPI specification

API version: 14
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package dokuwiki

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// MediaAPIService MediaAPI service
type MediaAPIService service

type ApiCoreDeleteMediaRequest struct {
	ctx context.Context
	ApiService *MediaAPIService
	coreDeleteMediaRequest *CoreDeleteMediaRequest
}

func (r ApiCoreDeleteMediaRequest) CoreDeleteMediaRequest(coreDeleteMediaRequest CoreDeleteMediaRequest) ApiCoreDeleteMediaRequest {
	r.coreDeleteMediaRequest = &coreDeleteMediaRequest
	return r
}

func (r ApiCoreDeleteMediaRequest) Execute() (*CoreSaveMedia200Response, *http.Response, error) {
	return r.ApiService.CoreDeleteMediaExecute(r)
}

/*
CoreDeleteMedia Deletes a file from the wiki

You need to have delete permissions for the file.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCoreDeleteMediaRequest
*/
func (a *MediaAPIService) CoreDeleteMedia(ctx context.Context) ApiCoreDeleteMediaRequest {
	return ApiCoreDeleteMediaRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CoreSaveMedia200Response
func (a *MediaAPIService) CoreDeleteMediaExecute(r ApiCoreDeleteMediaRequest) (*CoreSaveMedia200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CoreSaveMedia200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MediaAPIService.CoreDeleteMedia")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/core.deleteMedia"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.coreDeleteMediaRequest == nil {
		return localVarReturnValue, nil, reportError("coreDeleteMediaRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.coreDeleteMediaRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCoreGetMediaRequest struct {
	ctx context.Context
	ApiService *MediaAPIService
	coreGetMediaRequest *CoreGetMediaRequest
}

func (r ApiCoreGetMediaRequest) CoreGetMediaRequest(coreGetMediaRequest CoreGetMediaRequest) ApiCoreGetMediaRequest {
	r.coreGetMediaRequest = &coreGetMediaRequest
	return r
}

func (r ApiCoreGetMediaRequest) Execute() (*CoreGetMedia200Response, *http.Response, error) {
	return r.ApiService.CoreGetMediaExecute(r)
}

/*
CoreGetMedia Get a media file's content

Returns the content of the given media file. When no revision is given, the current revision is returned.

**See also:**

* https://en.wikipedia.org/wiki/Base64

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCoreGetMediaRequest
*/
func (a *MediaAPIService) CoreGetMedia(ctx context.Context) ApiCoreGetMediaRequest {
	return ApiCoreGetMediaRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CoreGetMedia200Response
func (a *MediaAPIService) CoreGetMediaExecute(r ApiCoreGetMediaRequest) (*CoreGetMedia200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CoreGetMedia200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MediaAPIService.CoreGetMedia")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/core.getMedia"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.coreGetMediaRequest == nil {
		return localVarReturnValue, nil, reportError("coreGetMediaRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.coreGetMediaRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCoreGetMediaHistoryRequest struct {
	ctx context.Context
	ApiService *MediaAPIService
	coreGetMediaHistoryRequest *CoreGetMediaHistoryRequest
}

func (r ApiCoreGetMediaHistoryRequest) CoreGetMediaHistoryRequest(coreGetMediaHistoryRequest CoreGetMediaHistoryRequest) ApiCoreGetMediaHistoryRequest {
	r.coreGetMediaHistoryRequest = &coreGetMediaHistoryRequest
	return r
}

func (r ApiCoreGetMediaHistoryRequest) Execute() (*CoreGetRecentMediaChanges200Response, *http.Response, error) {
	return r.ApiService.CoreGetMediaHistoryExecute(r)
}

/*
CoreGetMediaHistory Returns a list of available revisions of a given media file

The number of returned files is set by `$conf['recent']`, but non accessible revisions
are skipped, so less than that may be returned.

Since API Version 14







@author

**See also:**

* [Config Recent](https://www.dokuwiki.org/config:recent)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCoreGetMediaHistoryRequest
*/
func (a *MediaAPIService) CoreGetMediaHistory(ctx context.Context) ApiCoreGetMediaHistoryRequest {
	return ApiCoreGetMediaHistoryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CoreGetRecentMediaChanges200Response
func (a *MediaAPIService) CoreGetMediaHistoryExecute(r ApiCoreGetMediaHistoryRequest) (*CoreGetRecentMediaChanges200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CoreGetRecentMediaChanges200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MediaAPIService.CoreGetMediaHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/core.getMediaHistory"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.coreGetMediaHistoryRequest == nil {
		return localVarReturnValue, nil, reportError("coreGetMediaHistoryRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.coreGetMediaHistoryRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCoreGetMediaInfoRequest struct {
	ctx context.Context
	ApiService *MediaAPIService
	coreGetMediaInfoRequest *CoreGetMediaInfoRequest
}

func (r ApiCoreGetMediaInfoRequest) CoreGetMediaInfoRequest(coreGetMediaInfoRequest CoreGetMediaInfoRequest) ApiCoreGetMediaInfoRequest {
	r.coreGetMediaInfoRequest = &coreGetMediaInfoRequest
	return r
}

func (r ApiCoreGetMediaInfoRequest) Execute() (*CoreGetMediaInfo200Response, *http.Response, error) {
	return r.ApiService.CoreGetMediaInfoExecute(r)
}

/*
CoreGetMediaInfo Return info about a media file

The call will return an error if the requested media file does not exist.

Read access is required for the media file.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCoreGetMediaInfoRequest
*/
func (a *MediaAPIService) CoreGetMediaInfo(ctx context.Context) ApiCoreGetMediaInfoRequest {
	return ApiCoreGetMediaInfoRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CoreGetMediaInfo200Response
func (a *MediaAPIService) CoreGetMediaInfoExecute(r ApiCoreGetMediaInfoRequest) (*CoreGetMediaInfo200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CoreGetMediaInfo200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MediaAPIService.CoreGetMediaInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/core.getMediaInfo"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.coreGetMediaInfoRequest == nil {
		return localVarReturnValue, nil, reportError("coreGetMediaInfoRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.coreGetMediaInfoRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCoreGetMediaUsageRequest struct {
	ctx context.Context
	ApiService *MediaAPIService
	coreGetMediaUsageRequest *CoreGetMediaUsageRequest
}

func (r ApiCoreGetMediaUsageRequest) CoreGetMediaUsageRequest(coreGetMediaUsageRequest CoreGetMediaUsageRequest) ApiCoreGetMediaUsageRequest {
	r.coreGetMediaUsageRequest = &coreGetMediaUsageRequest
	return r
}

func (r ApiCoreGetMediaUsageRequest) Execute() (*CoreGetPageBackLinks200Response, *http.Response, error) {
	return r.ApiService.CoreGetMediaUsageExecute(r)
}

/*
CoreGetMediaUsage Returns the pages that use a given media file

The call will return an error if the requested media file does not exist.

Read access is required for the media file.

Since API Version 13

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCoreGetMediaUsageRequest
*/
func (a *MediaAPIService) CoreGetMediaUsage(ctx context.Context) ApiCoreGetMediaUsageRequest {
	return ApiCoreGetMediaUsageRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CoreGetPageBackLinks200Response
func (a *MediaAPIService) CoreGetMediaUsageExecute(r ApiCoreGetMediaUsageRequest) (*CoreGetPageBackLinks200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CoreGetPageBackLinks200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MediaAPIService.CoreGetMediaUsage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/core.getMediaUsage"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.coreGetMediaUsageRequest == nil {
		return localVarReturnValue, nil, reportError("coreGetMediaUsageRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.coreGetMediaUsageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCoreGetRecentMediaChangesRequest struct {
	ctx context.Context
	ApiService *MediaAPIService
	coreGetRecentPageChangesRequest *CoreGetRecentPageChangesRequest
}

func (r ApiCoreGetRecentMediaChangesRequest) CoreGetRecentPageChangesRequest(coreGetRecentPageChangesRequest CoreGetRecentPageChangesRequest) ApiCoreGetRecentMediaChangesRequest {
	r.coreGetRecentPageChangesRequest = &coreGetRecentPageChangesRequest
	return r
}

func (r ApiCoreGetRecentMediaChangesRequest) Execute() (*CoreGetRecentMediaChanges200Response, *http.Response, error) {
	return r.ApiService.CoreGetRecentMediaChangesExecute(r)
}

/*
CoreGetRecentMediaChanges Get recent media changes

Returns a list of recent changes to media files. The results can be limited to changes newer than
a given timestamp.

Only changes within the configured `$conf['recent']` range are returned. This is the default
when no timestamp is given.

**See also:**

* [Config Recent](https://www.dokuwiki.org/config:recent)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCoreGetRecentMediaChangesRequest
*/
func (a *MediaAPIService) CoreGetRecentMediaChanges(ctx context.Context) ApiCoreGetRecentMediaChangesRequest {
	return ApiCoreGetRecentMediaChangesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CoreGetRecentMediaChanges200Response
func (a *MediaAPIService) CoreGetRecentMediaChangesExecute(r ApiCoreGetRecentMediaChangesRequest) (*CoreGetRecentMediaChanges200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CoreGetRecentMediaChanges200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MediaAPIService.CoreGetRecentMediaChanges")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/core.getRecentMediaChanges"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.coreGetRecentPageChangesRequest == nil {
		return localVarReturnValue, nil, reportError("coreGetRecentPageChangesRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.coreGetRecentPageChangesRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCoreListMediaRequest struct {
	ctx context.Context
	ApiService *MediaAPIService
	coreListMediaRequest *CoreListMediaRequest
}

func (r ApiCoreListMediaRequest) CoreListMediaRequest(coreListMediaRequest CoreListMediaRequest) ApiCoreListMediaRequest {
	r.coreListMediaRequest = &coreListMediaRequest
	return r
}

func (r ApiCoreListMediaRequest) Execute() (*CoreListMedia200Response, *http.Response, error) {
	return r.ApiService.CoreListMediaExecute(r)
}

/*
CoreListMedia List all media files in the given namespace (and below)

Setting the `depth` to `0` and the `namespace` to `""` will return all media files in the wiki.

When `pattern` is given, it needs to be a valid regular expression as understood by PHP's
`preg_match()` including delimiters.
The pattern is matched against the full media ID, including the namespace.

**See also:**

* https://www.php.net/manual/en/reference.pcre.pattern.syntax.php

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCoreListMediaRequest
*/
func (a *MediaAPIService) CoreListMedia(ctx context.Context) ApiCoreListMediaRequest {
	return ApiCoreListMediaRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CoreListMedia200Response
func (a *MediaAPIService) CoreListMediaExecute(r ApiCoreListMediaRequest) (*CoreListMedia200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CoreListMedia200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MediaAPIService.CoreListMedia")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/core.listMedia"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.coreListMediaRequest == nil {
		return localVarReturnValue, nil, reportError("coreListMediaRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.coreListMediaRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCoreSaveMediaRequest struct {
	ctx context.Context
	ApiService *MediaAPIService
	coreSaveMediaRequest *CoreSaveMediaRequest
}

func (r ApiCoreSaveMediaRequest) CoreSaveMediaRequest(coreSaveMediaRequest CoreSaveMediaRequest) ApiCoreSaveMediaRequest {
	r.coreSaveMediaRequest = &coreSaveMediaRequest
	return r
}

func (r ApiCoreSaveMediaRequest) Execute() (*CoreSaveMedia200Response, *http.Response, error) {
	return r.ApiService.CoreSaveMediaExecute(r)
}

/*
CoreSaveMedia Uploads a file to the wiki

The file data has to be passed as a base64 encoded string.

**See also:**

* https://en.wikipedia.org/wiki/Base64

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCoreSaveMediaRequest
*/
func (a *MediaAPIService) CoreSaveMedia(ctx context.Context) ApiCoreSaveMediaRequest {
	return ApiCoreSaveMediaRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CoreSaveMedia200Response
func (a *MediaAPIService) CoreSaveMediaExecute(r ApiCoreSaveMediaRequest) (*CoreSaveMedia200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CoreSaveMedia200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MediaAPIService.CoreSaveMedia")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/core.saveMedia"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.coreSaveMediaRequest == nil {
		return localVarReturnValue, nil, reportError("coreSaveMediaRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.coreSaveMediaRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
