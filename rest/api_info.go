/*
DokuWiki API

The DokuWiki API OpenAPI specification

API version: 14
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package dokuwiki

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// InfoAPIService InfoAPI service
type InfoAPIService service

type ApiCoreGetAPIVersionRequest struct {
	ctx context.Context
	ApiService *InfoAPIService
	body *nil
}

func (r ApiCoreGetAPIVersionRequest) Body(body nil) ApiCoreGetAPIVersionRequest {
	r.body = &body
	return r
}

func (r ApiCoreGetAPIVersionRequest) Execute() (*CoreGetAPIVersion200Response, *http.Response, error) {
	return r.ApiService.CoreGetAPIVersionExecute(r)
}

/*
CoreGetAPIVersion Return the API version

This method is public and does not require authentication. 

This is the version of the DokuWiki API. It increases whenever the API definition changes.

When developing a client, you should check this version and make sure you can handle it.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCoreGetAPIVersionRequest
*/
func (a *InfoAPIService) CoreGetAPIVersion(ctx context.Context) ApiCoreGetAPIVersionRequest {
	return ApiCoreGetAPIVersionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CoreGetAPIVersion200Response
func (a *InfoAPIService) CoreGetAPIVersionExecute(r ApiCoreGetAPIVersionRequest) (*CoreGetAPIVersion200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CoreGetAPIVersion200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InfoAPIService.CoreGetAPIVersion")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/core.getAPIVersion"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCoreGetWikiTimeRequest struct {
	ctx context.Context
	ApiService *InfoAPIService
	body *nil
}

func (r ApiCoreGetWikiTimeRequest) Body(body nil) ApiCoreGetWikiTimeRequest {
	r.body = &body
	return r
}

func (r ApiCoreGetWikiTimeRequest) Execute() (*CoreGetWikiTime200Response, *http.Response, error) {
	return r.ApiService.CoreGetWikiTimeExecute(r)
}

/*
CoreGetWikiTime Return the current server time

Returns a Unix timestamp (seconds since 1970-01-01 00:00:00 UTC).

You can use this to compensate for differences between your client's time and the
server's time when working with last modified timestamps (revisions).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCoreGetWikiTimeRequest
*/
func (a *InfoAPIService) CoreGetWikiTime(ctx context.Context) ApiCoreGetWikiTimeRequest {
	return ApiCoreGetWikiTimeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CoreGetWikiTime200Response
func (a *InfoAPIService) CoreGetWikiTimeExecute(r ApiCoreGetWikiTimeRequest) (*CoreGetWikiTime200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CoreGetWikiTime200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InfoAPIService.CoreGetWikiTime")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/core.getWikiTime"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCoreGetWikiTitleRequest struct {
	ctx context.Context
	ApiService *InfoAPIService
	body *nil
}

func (r ApiCoreGetWikiTitleRequest) Body(body nil) ApiCoreGetWikiTitleRequest {
	r.body = &body
	return r
}

func (r ApiCoreGetWikiTitleRequest) Execute() (*CoreGetWikiTitle200Response, *http.Response, error) {
	return r.ApiService.CoreGetWikiTitleExecute(r)
}

/*
CoreGetWikiTitle Returns the wiki title

This method is public and does not require authentication. 



**See also:**

* [Config Title](https://www.dokuwiki.org/config:title)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCoreGetWikiTitleRequest
*/
func (a *InfoAPIService) CoreGetWikiTitle(ctx context.Context) ApiCoreGetWikiTitleRequest {
	return ApiCoreGetWikiTitleRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CoreGetWikiTitle200Response
func (a *InfoAPIService) CoreGetWikiTitleExecute(r ApiCoreGetWikiTitleRequest) (*CoreGetWikiTitle200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CoreGetWikiTitle200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InfoAPIService.CoreGetWikiTitle")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/core.getWikiTitle"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCoreGetWikiVersionRequest struct {
	ctx context.Context
	ApiService *InfoAPIService
	body *nil
}

func (r ApiCoreGetWikiVersionRequest) Body(body nil) ApiCoreGetWikiVersionRequest {
	r.body = &body
	return r
}

func (r ApiCoreGetWikiVersionRequest) Execute() (*CoreGetWikiVersion200Response, *http.Response, error) {
	return r.ApiService.CoreGetWikiVersionExecute(r)
}

/*
CoreGetWikiVersion Return DokuWiki's version

This returns the version in the form "Type Date (SHA)". Where type is either
"Release" or "Git" and date is the date of the release or the date of the
last commit. SHA is the short SHA of the last commit - this is only added on
git checkouts.

If no version can be determined "snapshot? update version XX" is returned.
Where XX represents the update version number set in doku.php.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCoreGetWikiVersionRequest
*/
func (a *InfoAPIService) CoreGetWikiVersion(ctx context.Context) ApiCoreGetWikiVersionRequest {
	return ApiCoreGetWikiVersionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CoreGetWikiVersion200Response
func (a *InfoAPIService) CoreGetWikiVersionExecute(r ApiCoreGetWikiVersionRequest) (*CoreGetWikiVersion200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CoreGetWikiVersion200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InfoAPIService.CoreGetWikiVersion")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/core.getWikiVersion"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
