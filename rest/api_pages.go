/*
DokuWiki API

The DokuWiki API OpenAPI specification

API version: 14
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package dokuwiki

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// PagesAPIService PagesAPI service
type PagesAPIService service

type ApiCoreAppendPageRequest struct {
	ctx context.Context
	ApiService *PagesAPIService
	coreSavePageRequest *CoreSavePageRequest
}

func (r ApiCoreAppendPageRequest) CoreSavePageRequest(coreSavePageRequest CoreSavePageRequest) ApiCoreAppendPageRequest {
	r.coreSavePageRequest = &coreSavePageRequest
	return r
}

func (r ApiCoreAppendPageRequest) Execute() (*CoreSavePage200Response, *http.Response, error) {
	return r.ApiService.CoreAppendPageExecute(r)
}

/*
CoreAppendPage Appends text to the end of a wiki page

If the page does not exist, it will be created. If a page template for the non-existant
page is configured, the given text will appended to that template.

The call will create a new page revision.

You need write permissions for the given page.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCoreAppendPageRequest
*/
func (a *PagesAPIService) CoreAppendPage(ctx context.Context) ApiCoreAppendPageRequest {
	return ApiCoreAppendPageRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CoreSavePage200Response
func (a *PagesAPIService) CoreAppendPageExecute(r ApiCoreAppendPageRequest) (*CoreSavePage200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CoreSavePage200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PagesAPIService.CoreAppendPage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/core.appendPage"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.coreSavePageRequest == nil {
		return localVarReturnValue, nil, reportError("coreSavePageRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.coreSavePageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCoreGetPageRequest struct {
	ctx context.Context
	ApiService *PagesAPIService
	coreGetPageRequest *CoreGetPageRequest
}

func (r ApiCoreGetPageRequest) CoreGetPageRequest(coreGetPageRequest CoreGetPageRequest) ApiCoreGetPageRequest {
	r.coreGetPageRequest = &coreGetPageRequest
	return r
}

func (r ApiCoreGetPageRequest) Execute() (*CoreGetPage200Response, *http.Response, error) {
	return r.ApiService.CoreGetPageExecute(r)
}

/*
CoreGetPage Get a wiki page's syntax

Returns the syntax of the given page. When no revision is given, the current revision is returned.

A non-existing page (or revision) will return an empty string usually. For the current revision
a page template will be returned if configured.

Read access is required for the page.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCoreGetPageRequest
*/
func (a *PagesAPIService) CoreGetPage(ctx context.Context) ApiCoreGetPageRequest {
	return ApiCoreGetPageRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CoreGetPage200Response
func (a *PagesAPIService) CoreGetPageExecute(r ApiCoreGetPageRequest) (*CoreGetPage200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CoreGetPage200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PagesAPIService.CoreGetPage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/core.getPage"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.coreGetPageRequest == nil {
		return localVarReturnValue, nil, reportError("coreGetPageRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.coreGetPageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCoreGetPageBackLinksRequest struct {
	ctx context.Context
	ApiService *PagesAPIService
	coreGetPageLinksRequest *CoreGetPageLinksRequest
}

func (r ApiCoreGetPageBackLinksRequest) CoreGetPageLinksRequest(coreGetPageLinksRequest CoreGetPageLinksRequest) ApiCoreGetPageBackLinksRequest {
	r.coreGetPageLinksRequest = &coreGetPageLinksRequest
	return r
}

func (r ApiCoreGetPageBackLinksRequest) Execute() (*CoreGetPageBackLinks200Response, *http.Response, error) {
	return r.ApiService.CoreGetPageBackLinksExecute(r)
}

/*
CoreGetPageBackLinks Get a page's backlinks

A backlink is a wiki link on another page that links to the given page.

Only links from pages readable by the current user are returned. The page itself
needs to be readable. Otherwise an error is returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCoreGetPageBackLinksRequest
*/
func (a *PagesAPIService) CoreGetPageBackLinks(ctx context.Context) ApiCoreGetPageBackLinksRequest {
	return ApiCoreGetPageBackLinksRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CoreGetPageBackLinks200Response
func (a *PagesAPIService) CoreGetPageBackLinksExecute(r ApiCoreGetPageBackLinksRequest) (*CoreGetPageBackLinks200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CoreGetPageBackLinks200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PagesAPIService.CoreGetPageBackLinks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/core.getPageBackLinks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.coreGetPageLinksRequest == nil {
		return localVarReturnValue, nil, reportError("coreGetPageLinksRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.coreGetPageLinksRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCoreGetPageHTMLRequest struct {
	ctx context.Context
	ApiService *PagesAPIService
	coreGetPageHTMLRequest *CoreGetPageHTMLRequest
}

func (r ApiCoreGetPageHTMLRequest) CoreGetPageHTMLRequest(coreGetPageHTMLRequest CoreGetPageHTMLRequest) ApiCoreGetPageHTMLRequest {
	r.coreGetPageHTMLRequest = &coreGetPageHTMLRequest
	return r
}

func (r ApiCoreGetPageHTMLRequest) Execute() (*CoreGetPageHTML200Response, *http.Response, error) {
	return r.ApiService.CoreGetPageHTMLExecute(r)
}

/*
CoreGetPageHTML Return a wiki page rendered to HTML

The page is rendered to HTML as it would be in the wiki. The HTML consist only of the data for the page
content itself, no surrounding structural tags, header, footers, sidebars etc are returned.

References in the HTML are relative to the wiki base URL unless the `canonical` configuration is set.

If the page does not exist, an error is returned.

**See also:**

* [Config Canonical](https://www.dokuwiki.org/config:canonical)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCoreGetPageHTMLRequest
*/
func (a *PagesAPIService) CoreGetPageHTML(ctx context.Context) ApiCoreGetPageHTMLRequest {
	return ApiCoreGetPageHTMLRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CoreGetPageHTML200Response
func (a *PagesAPIService) CoreGetPageHTMLExecute(r ApiCoreGetPageHTMLRequest) (*CoreGetPageHTML200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CoreGetPageHTML200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PagesAPIService.CoreGetPageHTML")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/core.getPageHTML"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.coreGetPageHTMLRequest == nil {
		return localVarReturnValue, nil, reportError("coreGetPageHTMLRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.coreGetPageHTMLRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCoreGetPageHistoryRequest struct {
	ctx context.Context
	ApiService *PagesAPIService
	coreGetPageHistoryRequest *CoreGetPageHistoryRequest
}

func (r ApiCoreGetPageHistoryRequest) CoreGetPageHistoryRequest(coreGetPageHistoryRequest CoreGetPageHistoryRequest) ApiCoreGetPageHistoryRequest {
	r.coreGetPageHistoryRequest = &coreGetPageHistoryRequest
	return r
}

func (r ApiCoreGetPageHistoryRequest) Execute() (*CoreGetRecentPageChanges200Response, *http.Response, error) {
	return r.ApiService.CoreGetPageHistoryExecute(r)
}

/*
CoreGetPageHistory Returns a list of available revisions of a given wiki page

The number of returned pages is set by `$conf['recent']`, but non accessible revisions
are skipped, so less than that may be returned.

**See also:**

* [Config Recent](https://www.dokuwiki.org/config:recent)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCoreGetPageHistoryRequest
*/
func (a *PagesAPIService) CoreGetPageHistory(ctx context.Context) ApiCoreGetPageHistoryRequest {
	return ApiCoreGetPageHistoryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CoreGetRecentPageChanges200Response
func (a *PagesAPIService) CoreGetPageHistoryExecute(r ApiCoreGetPageHistoryRequest) (*CoreGetRecentPageChanges200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CoreGetRecentPageChanges200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PagesAPIService.CoreGetPageHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/core.getPageHistory"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.coreGetPageHistoryRequest == nil {
		return localVarReturnValue, nil, reportError("coreGetPageHistoryRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.coreGetPageHistoryRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCoreGetPageInfoRequest struct {
	ctx context.Context
	ApiService *PagesAPIService
	coreGetPageInfoRequest *CoreGetPageInfoRequest
}

func (r ApiCoreGetPageInfoRequest) CoreGetPageInfoRequest(coreGetPageInfoRequest CoreGetPageInfoRequest) ApiCoreGetPageInfoRequest {
	r.coreGetPageInfoRequest = &coreGetPageInfoRequest
	return r
}

func (r ApiCoreGetPageInfoRequest) Execute() (*CoreGetPageInfo200Response, *http.Response, error) {
	return r.ApiService.CoreGetPageInfoExecute(r)
}

/*
CoreGetPageInfo Return some basic data about a page

The call will return an error if the requested page does not exist.

Read access is required for the page.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCoreGetPageInfoRequest
*/
func (a *PagesAPIService) CoreGetPageInfo(ctx context.Context) ApiCoreGetPageInfoRequest {
	return ApiCoreGetPageInfoRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CoreGetPageInfo200Response
func (a *PagesAPIService) CoreGetPageInfoExecute(r ApiCoreGetPageInfoRequest) (*CoreGetPageInfo200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CoreGetPageInfo200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PagesAPIService.CoreGetPageInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/core.getPageInfo"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.coreGetPageInfoRequest == nil {
		return localVarReturnValue, nil, reportError("coreGetPageInfoRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.coreGetPageInfoRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCoreGetPageLinksRequest struct {
	ctx context.Context
	ApiService *PagesAPIService
	coreGetPageLinksRequest *CoreGetPageLinksRequest
}

func (r ApiCoreGetPageLinksRequest) CoreGetPageLinksRequest(coreGetPageLinksRequest CoreGetPageLinksRequest) ApiCoreGetPageLinksRequest {
	r.coreGetPageLinksRequest = &coreGetPageLinksRequest
	return r
}

func (r ApiCoreGetPageLinksRequest) Execute() (*CoreGetPageLinks200Response, *http.Response, error) {
	return r.ApiService.CoreGetPageLinksExecute(r)
}

/*
CoreGetPageLinks Get a page's links

This returns a list of links found in the given page. This includes internal, external and interwiki links

If a link occurs multiple times on the page, it will be returned multiple times.

Read access for the given page is needed and page has to exist.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCoreGetPageLinksRequest
*/
func (a *PagesAPIService) CoreGetPageLinks(ctx context.Context) ApiCoreGetPageLinksRequest {
	return ApiCoreGetPageLinksRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CoreGetPageLinks200Response
func (a *PagesAPIService) CoreGetPageLinksExecute(r ApiCoreGetPageLinksRequest) (*CoreGetPageLinks200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CoreGetPageLinks200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PagesAPIService.CoreGetPageLinks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/core.getPageLinks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.coreGetPageLinksRequest == nil {
		return localVarReturnValue, nil, reportError("coreGetPageLinksRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.coreGetPageLinksRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCoreGetRecentPageChangesRequest struct {
	ctx context.Context
	ApiService *PagesAPIService
	coreGetRecentPageChangesRequest *CoreGetRecentPageChangesRequest
}

func (r ApiCoreGetRecentPageChangesRequest) CoreGetRecentPageChangesRequest(coreGetRecentPageChangesRequest CoreGetRecentPageChangesRequest) ApiCoreGetRecentPageChangesRequest {
	r.coreGetRecentPageChangesRequest = &coreGetRecentPageChangesRequest
	return r
}

func (r ApiCoreGetRecentPageChangesRequest) Execute() (*CoreGetRecentPageChanges200Response, *http.Response, error) {
	return r.ApiService.CoreGetRecentPageChangesExecute(r)
}

/*
CoreGetRecentPageChanges Get recent page changes

Returns a list of recent changes to wiki pages. The results can be limited to changes newer than
a given timestamp.

Only changes within the configured `$conf['recent']` range are returned. This is the default
when no timestamp is given.

**See also:**

* [Config Recent](https://www.dokuwiki.org/config:recent)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCoreGetRecentPageChangesRequest
*/
func (a *PagesAPIService) CoreGetRecentPageChanges(ctx context.Context) ApiCoreGetRecentPageChangesRequest {
	return ApiCoreGetRecentPageChangesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CoreGetRecentPageChanges200Response
func (a *PagesAPIService) CoreGetRecentPageChangesExecute(r ApiCoreGetRecentPageChangesRequest) (*CoreGetRecentPageChanges200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CoreGetRecentPageChanges200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PagesAPIService.CoreGetRecentPageChanges")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/core.getRecentPageChanges"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.coreGetRecentPageChangesRequest == nil {
		return localVarReturnValue, nil, reportError("coreGetRecentPageChangesRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.coreGetRecentPageChangesRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCoreListPagesRequest struct {
	ctx context.Context
	ApiService *PagesAPIService
	coreListPagesRequest *CoreListPagesRequest
}

func (r ApiCoreListPagesRequest) CoreListPagesRequest(coreListPagesRequest CoreListPagesRequest) ApiCoreListPagesRequest {
	r.coreListPagesRequest = &coreListPagesRequest
	return r
}

func (r ApiCoreListPagesRequest) Execute() (*CoreListPages200Response, *http.Response, error) {
	return r.ApiService.CoreListPagesExecute(r)
}

/*
CoreListPages List all pages in the given namespace (and below)

Setting the `depth` to `0` and the `namespace` to `""` will return all pages in the wiki.

Note: author information is not available in this call.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCoreListPagesRequest
*/
func (a *PagesAPIService) CoreListPages(ctx context.Context) ApiCoreListPagesRequest {
	return ApiCoreListPagesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CoreListPages200Response
func (a *PagesAPIService) CoreListPagesExecute(r ApiCoreListPagesRequest) (*CoreListPages200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CoreListPages200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PagesAPIService.CoreListPages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/core.listPages"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.coreListPagesRequest == nil {
		return localVarReturnValue, nil, reportError("coreListPagesRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.coreListPagesRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCoreLockPagesRequest struct {
	ctx context.Context
	ApiService *PagesAPIService
	coreLockPagesRequest *CoreLockPagesRequest
}

func (r ApiCoreLockPagesRequest) CoreLockPagesRequest(coreLockPagesRequest CoreLockPagesRequest) ApiCoreLockPagesRequest {
	r.coreLockPagesRequest = &coreLockPagesRequest
	return r
}

func (r ApiCoreLockPagesRequest) Execute() (*CoreLockPages200Response, *http.Response, error) {
	return r.ApiService.CoreLockPagesExecute(r)
}

/*
CoreLockPages Lock the given set of pages

This call will try to lock all given pages. It will return a list of pages that were
successfully locked. If a page could not be locked, eg. because a different user is
currently holding a lock, that page will be missing from the returned list.

You should always ensure that the list of returned pages matches the given list of
pages. It's up to you to decide how to handle failed locking.

Note: you can only lock pages that you have write access for. It is possible to create
a lock for a page that does not exist, yet.

Note: it is not necessary to lock a page before saving it. The `savePage()` call will
automatically lock and unlock the page for you. However if you plan to do related
operations on multiple pages, locking them all at once beforehand can be useful.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCoreLockPagesRequest
*/
func (a *PagesAPIService) CoreLockPages(ctx context.Context) ApiCoreLockPagesRequest {
	return ApiCoreLockPagesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CoreLockPages200Response
func (a *PagesAPIService) CoreLockPagesExecute(r ApiCoreLockPagesRequest) (*CoreLockPages200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CoreLockPages200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PagesAPIService.CoreLockPages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/core.lockPages"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.coreLockPagesRequest == nil {
		return localVarReturnValue, nil, reportError("coreLockPagesRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.coreLockPagesRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCoreSavePageRequest struct {
	ctx context.Context
	ApiService *PagesAPIService
	coreSavePageRequest *CoreSavePageRequest
}

func (r ApiCoreSavePageRequest) CoreSavePageRequest(coreSavePageRequest CoreSavePageRequest) ApiCoreSavePageRequest {
	r.coreSavePageRequest = &coreSavePageRequest
	return r
}

func (r ApiCoreSavePageRequest) Execute() (*CoreSavePage200Response, *http.Response, error) {
	return r.ApiService.CoreSavePageExecute(r)
}

/*
CoreSavePage Save a wiki page

Saves the given wiki text to the given page. If the page does not exist, it will be created.
Just like in the wiki, saving an empty text will delete the page.

You need write permissions for the given page and the page may not be locked by another user.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCoreSavePageRequest
*/
func (a *PagesAPIService) CoreSavePage(ctx context.Context) ApiCoreSavePageRequest {
	return ApiCoreSavePageRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CoreSavePage200Response
func (a *PagesAPIService) CoreSavePageExecute(r ApiCoreSavePageRequest) (*CoreSavePage200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CoreSavePage200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PagesAPIService.CoreSavePage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/core.savePage"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.coreSavePageRequest == nil {
		return localVarReturnValue, nil, reportError("coreSavePageRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.coreSavePageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCoreSearchPagesRequest struct {
	ctx context.Context
	ApiService *PagesAPIService
	coreSearchPagesRequest *CoreSearchPagesRequest
}

func (r ApiCoreSearchPagesRequest) CoreSearchPagesRequest(coreSearchPagesRequest CoreSearchPagesRequest) ApiCoreSearchPagesRequest {
	r.coreSearchPagesRequest = &coreSearchPagesRequest
	return r
}

func (r ApiCoreSearchPagesRequest) Execute() (*CoreSearchPages200Response, *http.Response, error) {
	return r.ApiService.CoreSearchPagesExecute(r)
}

/*
CoreSearchPages Do a fulltext search

This executes a full text search and returns the results. The query uses the standard
DokuWiki search syntax.

Snippets are provided for the first 15 results only. The title is either the first heading
or the page id depending on the wiki's configuration.

**See also:**

* [Search Syntax](https://www.dokuwiki.org/search#syntax)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCoreSearchPagesRequest
*/
func (a *PagesAPIService) CoreSearchPages(ctx context.Context) ApiCoreSearchPagesRequest {
	return ApiCoreSearchPagesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CoreSearchPages200Response
func (a *PagesAPIService) CoreSearchPagesExecute(r ApiCoreSearchPagesRequest) (*CoreSearchPages200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CoreSearchPages200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PagesAPIService.CoreSearchPages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/core.searchPages"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.coreSearchPagesRequest == nil {
		return localVarReturnValue, nil, reportError("coreSearchPagesRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.coreSearchPagesRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCoreUnlockPagesRequest struct {
	ctx context.Context
	ApiService *PagesAPIService
	coreUnlockPagesRequest *CoreUnlockPagesRequest
}

func (r ApiCoreUnlockPagesRequest) CoreUnlockPagesRequest(coreUnlockPagesRequest CoreUnlockPagesRequest) ApiCoreUnlockPagesRequest {
	r.coreUnlockPagesRequest = &coreUnlockPagesRequest
	return r
}

func (r ApiCoreUnlockPagesRequest) Execute() (*CoreUnlockPages200Response, *http.Response, error) {
	return r.ApiService.CoreUnlockPagesExecute(r)
}

/*
CoreUnlockPages Unlock the given set of pages

This call will try to unlock all given pages. It will return a list of pages that were
successfully unlocked. If a page could not be unlocked, eg. because a different user is
currently holding a lock, that page will be missing from the returned list.

You should always ensure that the list of returned pages matches the given list of
pages. It's up to you to decide how to handle failed unlocking.

Note: you can only unlock pages that you have write access for.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCoreUnlockPagesRequest
*/
func (a *PagesAPIService) CoreUnlockPages(ctx context.Context) ApiCoreUnlockPagesRequest {
	return ApiCoreUnlockPagesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CoreUnlockPages200Response
func (a *PagesAPIService) CoreUnlockPagesExecute(r ApiCoreUnlockPagesRequest) (*CoreUnlockPages200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CoreUnlockPages200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PagesAPIService.CoreUnlockPages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/core.unlockPages"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.coreUnlockPagesRequest == nil {
		return localVarReturnValue, nil, reportError("coreUnlockPagesRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.coreUnlockPagesRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
